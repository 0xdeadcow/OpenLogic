% Part: computability
% Chapter: recursive-functions
% Section: bounded-minimization

\documentclass[../../include/open-logic-section]{subfiles}

\begin{document}

\olfileid{cmp}{rec}{bmi}
\olsection{Bounded Minimization}


\begin{prop}
If $R(x, \vec z)$ is primitive recursive, so is the function $m_R(y,
\vec z)$ which returns the least~$x$ less than $y$ such that $R(x,\vec
z)$ holds, if there is one, and 0 otherwise.  We will write the
function~$m_R$ as
\[
\fn{min} \; x < y \; R(x, \vec z),
\]
\end{prop}

\begin{proof}
We first define the function~$m'_R(y, \vec z)$ which returns the
least~$x$ less than $y$ such that $R(x,\vec z)$ holds, if there is
one, and $y$ otherwise.  First, we define 
\[
f(u, \vec z) = 
\begin{cases}
0 & \text{if $\lexists[x \le u][R(x, \vec z)]$} \\
1 & \text{otherwise.}
\end{cases}
\]
$f$ is primitive recursive.  $f(u, \vec z)$ is 1 for all $u$ less than
the least $x$ such that $R(x, \vec z)$, and is~$0$ thereafter.  Since
there are exactly $x$ natural numbers less than~$x$, if we sum the
values of $f(u, \vec z)$ for all $u = 0$, \dots,~$y$, we get the least
$x$ such that $R(x, \vec z)$ if that $x$ is less than $y$, and $y+1$
otherwise:
\[
m'_R(y, \vec z) = \sum_{u = 0}^y f(u, \vec z)
\]
To get $m_R$, we set:
\[
m_R(u, \vec z) = 
\begin{cases}
m'_R(y, \vec z) & \text{if $m'_R(y, \vec z) < y$}\\
0 & \text{otherwise.}
\end{cases}
\]
\end{proof}

\begin{explain}
The choice of ``$0$ otherwise'' is somewhat arbitrary. As we saw, it
is in fact easier to recursively define the function~$m'$ which
returns the least $x$ less than $y$ such that $R(x,\vec z)$ holds, and
$y+1$ otherwise.  When we use $\fn{min}$, however, we will always know
that the least $x$ such that $R(x, \vec z)$ exists and is less than
$y$. Thus, in practice, we will not have to worry about the
possibility that if $\fn{min}$ returns $0$ we do not know if that
value indicates that $R(0, \vec z)$ or that for no $x < y$, $R(x, \vec
z)$. As with bounded quantification, $\fn{min} \; x \leq y \; \dots$
can be understood as $\fn{min} \; x < y + 1 \; \dots$.
\end{explain}

All this provides us with a good deal of machinery to show that
natural functions and relations are primitive recursive. For example,
the following are all primitive recursive:
\begin{enumerate}
\item The relation ``$x$ divides $y$'', written $x \mid y$, defined by
\[
x \mid y \defiff \lexists[z \leq y][(x \cdot z) = y].
\]

\item The relation $\fn{Prime}(x)$, which holds iff $x$ is prime,
  defined by
\[
\fn{Prime}(x) \defiff (x \geq 2 \land \lforall[y \leq x][(y \mid x \lif y
  = 1 \lor y = x))].
\]
\item The function $\fn{nextPrime(x)}$, which returns the first prime
  number larger than $x$, defined by
\[
  \fn{nextPrime(x)} = \fn{min} \; {y \leq x\fac+1} \\ (y > x \land \fn{Prime}(y))
\]
Here we are relying on Euclid's proof of the fact that there is always
a prime number between $x$ and $x\fac+1$.

\item The function $p(x)$, returning the $x$th prime, defined by $p(0)
  = 2, p(x+1) = \fn{nextPrime}(p(x))$. For convenience we will write
  this as $p_x$ (starting with 0; i.e.\ $p_0=2$).
\end{enumerate}

\begin{prob}
Define integer division using bounded minimization.
\end{prob}

\end{document}
