% Part: turing-machines
% Chapter: machines-computations
% Section: representing-tms

\documentclass[../../../include/open-logic-section]{subfiles}

\begin{document}

\olfileid{tms}{tms}{dia}
\olsection{Representing Turing Machines}

\begin{explain}
Turing machines can be represented visually by \emph{state diagrams}. 
The diagrams are composed of
state cells connected by arrows. Unsurprisingly, each state cell represents
a state of the machine. Each arrow represents an instruction that can be
carried out from that state, with the specifics of the instruction written above
or below the appropriate arrow. Consider the following machine, which has 
only two internal states, $q_0$ and $q_1$, and one instruction:
\[
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,
                    semithick]
  \tikzstyle{every state}=[fill=none,draw=black,text=black]

  \node[state]   (A)              {$q_0$};
  \node[state]   (B) [right of=A] {$q_1$};

  \path (A) edge  node {\TMtrans{\TMblank}{\TMstroke}{\TMright}} (B);
\end{tikzpicture}
\]
Recall that the Turing machine has a read/write head and a tape with the
input written on it. The instruction can be read as \emph{if reading a blank in
state $q_0$, write a stroke, move right, and move to state $q_1$}. This is
equivalent to the instruction tuple $\tuple{q_0, \TMblank, q_1, \TMstroke, 
\TMright}$.
\end{explain}

\begin{ex}
\emph{Even Machine}: The following Turing machine halts if, and only if, there 
are an even number of strokes on the tape.
\[
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,
                    semithick]
  \tikzstyle{every state}=[fill=none,draw=black,text=black]

  \node[state]         (A)              {$q_0$};
  \node[state]         (B) [right of=A] {$q_1$};

  \path (A) edge [bend left] node {\TMtrans{\TMstroke}{\TMstroke}{\TMright}} (B)
        (B) edge [loop above] node {\TMtrans{\TMblank}{\TMblank}{\TMright}} (B)
            edge [bend left] node {\TMtrans{\TMstroke}{\TMstroke}{\TMright}} (A);
\end{tikzpicture}
\]

The state diagram corresponds to the following instruction set,
written as 5-tuples:
\begin{align*}
  & \tuple{q_0, \TMstroke, q_1, \TMstroke, \TMright},\\
  & \tuple{q_1, \TMblank, q_1, \TMblank, \TMright},\\
  & \tuple{q_1, \TMstroke, q_0, \TMstroke, \TMright} 
\end{align*}
\end{ex}

\begin{explain}
The above machine halts only when the input is an even number of strokes.
Otherwise, the machine (theoretically) continues to operate indefinitely. 
For any machine and input, it is possible to trace through the 
\emph{configurations} of the machine in order to determine the output. 
We will give a formal definition of configurations later. For now,
we can intuitively think of configurations as a series of diagrams showing the 
state of the machine at any point in time during operation.
Configurations show the content of the tape, the state of the machine and the
location of the read/write head.

Let us trace through the configurations of the even machine if it is
started with an input of $4$ $\TMstroke$s. In this case, we expect that the
machine will halt.  We will then run the machine on an input of ~$3$
$\TMstroke$s, where the machine will get caught in a loop.

The machine starts in state~$q_0$, scanning the leftmost~$\TMstroke$.
We can represent the initial state of the machine as follows:
\[
\TMendtape \TMstroke_0 \TMstroke \TMstroke \TMstroke \TMblank \ldots
\]
The above configuration is straightforward. As can be seen, the
machine starts in state one, scanning the leftmost~$\TMstroke$. This
is represented by a subscript of the state name on the
first~$\TMstroke$. The applicable instruction at this point is
$\langle q_0, \TMstroke, q_1, \TMstroke, \TMright \rangle$, and so the
machine moves right on the tape and changes to state~$q_1$.
\[
\TMendtape \TMstroke \TMstroke_1 \TMstroke \TMstroke \TMblank \ldots
\]
Since the machine is now in state~$q_1$ scanning a stroke, we have to
``follow'' the instruction $\langle q_1, \TMstroke, q_0, \TMstroke,
\TMright \rangle$. This results in the configuration
\[
\TMendtape \TMstroke \TMstroke \TMstroke_0 \TMstroke \TMblank \ldots
\]
As the machine loops, the rules are applied again in the same order, resulting
in the following two configurations:
\[
\TMendtape \TMstroke \TMstroke \TMstroke \TMstroke_1 \TMblank \ldots
\]
\[
\TMendtape \TMstroke \TMstroke \TMstroke \TMstroke \TMblank_0 \ldots
\]
The machine is now in state~$q_0$ scanning a blank. Based on the
transition diagram, we can easily see that there is no instruction to be
carry out, and thus the machine has halted. This means that the input
has been accepted.

Suppose next we start the machine with an input of three strokes. The
first few configurations are similar, as the same instructions are carried, with
only a small difference of the tape input:
\[
\TMendtape \TMstroke_0 \TMstroke \TMstroke \TMblank \ldots
\]
\[
\TMendtape \TMstroke \TMstroke_1 \TMstroke \TMblank \ldots
\]
\[
\TMendtape \TMstroke \TMstroke \TMstroke_0 \TMblank \ldots
\]
\[
\TMendtape \TMstroke \TMstroke \TMstroke \TMblank_1 \ldots
\]
The machine has now traversed past all the strokes, and is reading
a blank in state~$q_1$. As shown in the diagram, there is an instruction
of the form $\tuple{q_1, \TMblank, q_1, \TMblank, \TMright}$.
Since the tape is inifinitely blank to the right, the machine will continue to
execute this instruction \emph{ad infinitum}. The machine will never halt,
and does not accept the input.
\end{explain}

\begin{explain}
It is important to note that not all machines will halt. If halting means that the
machine runs out of instructions to execute, then we can 
create a machine that never halts simply by ensuring that there is an outgoing 
arrow for each symbol at each state. The even machine can be modified 
to run infnitely by adding an instruction for scanning a blank at~$q_0$.
\end{explain}

\begin{ex}
\[
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,
                    semithick]
  \tikzstyle{every state}=[fill=none,draw=black,text=black]

  \node[state]         (A)                     {$q_0$};
  \node[state]         (B) [right of=A] {$q_1$};

  \path (A) edge [bend left] node {$\TMstroke$,$\TMstroke$,$\TMright$} (B)
            edge [loop above] node {$\TMblank$,$\TMblank$,$\TMright$} (A)
        (B) edge [loop above] node {$\TMblank$,$\TMblank$,$\TMright$} (B)
            edge [bend left] node {$\TMstroke$,$\TMstroke$,$\TMright$} (A);
\end{tikzpicture}
\]
\end{ex}

\begin{explain}
Machine tables are another way of representing Turing
machines. Machine tables have the tape alphabet displayed on the
$x$-axis, and the set of machine states across the $y$-axis. Inside the
table, at the intersection of each state and symbol, is written the
rest of the instruction---the new state, new symbol, and direction of
movement. Machine tables make it easy to determine in what state, and
for what symbol, the machine halts. Whenever there is a gap in the
table is a possible point for the machine to halt. Unlike state
diagrams and instruction sets, where the points at which the machine
halts are not always immediately obvious, any halting points are
quickly identified by finding the gaps in the machine table.
\end{explain}

\begin{ex}
The machine table for the even machine is:
\[
\centering
\begin{tabular}{lllll}
\cline{2-3}
\multicolumn{1}{l|}{}      & \multicolumn{1}{l|}{$\TMblank$}                
& \multicolumn{1}{l|}{$\TMstroke$}                &  &  \\ \cline{1-3}
\multicolumn{1}{|l|}{$q_0$} & \multicolumn{1}{l|}{}                          
& \multicolumn{1}{l|}{$\TMstroke, q_1, \TMright$} &  &  \\ \cline{1-3}
\multicolumn{1}{|l|}{$q_1$} & \multicolumn{1}{l|}{$\TMblank, q_1, \TMblank$} 
& \multicolumn{1}{l|}{$\TMstroke, q_0, \TMright$} &  &  \\ \cline{1-3}
\end{tabular}
\]
As we can see, the machine halts when scanning a blank in state $q_0$.
\end{ex}

\begin{explain}
So far we have only considered machines that read and accept input. However, 
Turing machines have the capacity to both read and write. An example of
such a machine (although there are many, many examples) is a \emph{doubler}.
A doubler, when started with a block of~$n$ strokes on the tape, outputs
a block of~$2n$ strokes.

Before building such a machine, it is important to come up with a 
\emph{strategy} for solving the problem. Since the machine (as we have 
formulated it) cannot remember how many strokes it has read, we need to
come up with a way to keep track of all the strokes
on the tape. One such way is to separate the output from the input with a
blank. The machine can then erase the first stroke from the input,
traverse over the rest of the input, leave a blank, and write two new strokes.
The machine will then go back and find the second stroke in the input, and
double that one as well. By erasing the input as the machine goes, we can guarantee
that no stroke is missed or doubled twice.
\end{explain}

\begin{ex}\emph{The Doubler}
\[
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,
                    semithick]
  \tikzstyle{every state}=[fill=none,draw=black,text=black]

  \node[state]         (1)                     {$q_0$};
  \node[state]         (2) [right of=1] {$q_1$};
  \node[state]         (3) [right of=2] {$q_2$};
  \node[state]         (4) [below of=3] {$q_3$};
  \node[state]         (5) [left of=4]       {$q_4$};
  \node[state]         (6) [left of=5]       {$q_5$};

  \path (1) edge              node {$\TMstroke$,$\TMblank$,$\TMright$} (2)
            (2) edge [loop above] node {$\TMstroke$,$\TMstroke$,$\TMright$} (2)
                 edge              node {$\TMblank$,$\TMblank$,$\TMleft$} (3)
            (3) edge [loop above] node {$\TMstroke$,$\TMstroke$,$\TMright$} (3)
                 edge  node {$\TMblank$,$\TMstroke$,$\TMright$} (4)
            (4) edge [loop below] node {$\TMblank$,$\TMstroke$,$\TMleft$} (4)
                 edge              node {$\TMstroke$,$\TMstroke$,$\TMleft$} (5)
            (5) edge [loop below]  node {$\TMstroke$,$\TMstroke$,$\TMleft$} (5)
                 edge              node {$\TMblank$,$\TMblank$,$\TMleft$} (6)
            (6) edge [loop below] node {$\TMstroke$,$\TMstroke$,$\TMleft$} (6)
                 edge              node {$\TMblank$,$\TMblank$,$\TMright$} (1);
\end{tikzpicture}
\]
\end{ex}

\begin{prob}
Choose an arbitary input and trace through the configurations of the
above machine.
\end{prob}

\begin{prob}
Come up with a new method for solving the doubler problem, then build
a machine that executes your method. Check that your machine works by
tracing through the configurations.
\end{prob}
\end{document}
