% Part: lambda-calculus
% Chapter: lambda-definability
% Section: fixpoints

\documentclass[../../../include/open-logic-section]{subfiles}

\begin{document}

\olfileid{lam}{ldf}{fp}

\olsection{Fixpoints}

Suppose we wanted to define the factorial function by recursion as a
term $\fn{Fac}$ with the following property:
\[
\fn{Fac} \eqs \lambd[n][\fn{IsZero}\, n\, \num 1 (\fn{Mult}\, n (\fn{Fac}(\fn{Pred} \, n)))]
\]
That is, the factorial of $n$ is $1$ if $n = 0$, and $n$ times the
factorial of $n-1$ otherwise.  Of course, we cannot define the term
$\fn{Fac}$ this way since $\fn{Fac}$ itself occurs in the right-hand
side. Such recursive definitions involving self-reference
are not part of lambda calculus. Defining a term, e.g., by
\[
\fn{Mult} \eqs \lambd[ab][a (\fn{Add}\, a) 0]
\]
only involves previosuly defined terms in the right-hand side, such as
$\fn{Add}$. We can always remove $\fn{Add}$ by replacing it with its
defining term.  This would give the term $\fn{Mult}$ as a pure lambda
term; if $\fn{Add}$ itself involved defined terms (as, e.g.,
$\fn{Add}'$ does), we woul continue this process and finally arrive at
a pure lambda term.

However this is not true in the case of recursive definitions like the
one of $\fn{Fac}$ above. If we replace the occurrence of $\fn{Fac}$ on
the right-hand side with the definition of $\fn{Fac}$ itself, we get:
\[
\fn{Fac} \eqs \lambd[n][\fn{IsZero}\, n\, \num{1}\, (\fn{Mult}\, n
  ((\lambd[n][\fn{IsZero} \, n \, \num 1\, (\fn{Mult}\, n\, (\fn{Fac}
    (\fn{Pred}\, n)))]) (\fn{Pred}\, n)))]
\]
and we still haven't gotten rid of $\fn{Fac}$ on the right-hand
side. Clearly, if we repeat this process, the definition keeps growing
longer and the process never results in a pure lambda term. Thus this
way of defining factorial (or more generally recursive functions)
is not feasible.

The recursive definition does tell us something, though: If $f$ were a
term representing the factorial function, then the term
\[
\fn{Fac}' = \lambd[x][\lambd[n][\fn{IsZero} \, n \, \num 1\, (\fn{Mult} \, n\, (x (\fn{Pred} n)))]]
\]
applied to the term $f$, i.e., $\fn{Fac}'\,f$, also represents the
factorial function.  That is, if we regard $\fn{Fac}'$ as a function
accepting a function and returning a function, the value of
$\fn{Fac'}\, f$ is just $f$, provided $f$ is the factorial. A function
$f$ with the property that $\fn{Fac}' \, f \red f$ is called a
\emph{fixpoint} of $\fn{Fac}'$. So, the factorial is a fixpoint of
$\fn{Fac}'$.

There are terms in the lambda calculus that compute the fixpoints of a
given term, and these terms can then be used to turn a term like
$\fn{Fac}'$ into the definition of the factorial. 

\begin{defn}
  \ollabel{defn:Turing-Y}
  The \emph{Y-combinator} is the term:
  \[
  Y = (\lambd[ux][x(uux)])(\lambd[ux][x(uux)])
  \]
\end{defn}

\begin{prop}
  $Y$ has the property that $Yg \red g(Yg)$ for any term $g$. In other
  words, $Yg$ is a fixpoint of~$g$.
\end{prop}

\begin{proof}
  Let's abbreviate $(\lambd[ux][x(uux)])$ by~$U$, so that $Y = UU$. Then
  \begin{align*}
    Y g &= (\lambd[ux][x(uux)])U\,g \\
    &\red (\lambd[x][x(UUx)])g\\
    & \red g(UUg) = g(Yg) \qedhere
  \end{align*}
\end{proof}

Of course, since $Yg$ is a redex, the reduction can continue indefinetely:
\begin{align*}
  Y g &\red g (Y g) \\
    &\red g (g (Y g)) \\
    &\red g(g (g (Y g)))
    &\ldots
\end{align*}
So we can think of $Yg$ as $g$ applied to itself infinitely many
times. If we apply $g$ to it one additional time, we---so to
speak---aren't doing anything extra; $g$ applied to $g$ applied
infinitely many times to $Yg$ is still $g$ applied to $Yg$ infinitely
many times. So $Yg$ is a fixpoint of $g$.

Note that the above sequence of $\beta$-reduction steps starting
with~$Yg$ is infinite. So if we apply $Yg$ to some term, i.e.,
consider $(Yg)N$, that term will also reduce to infinitely many
different terms, namely $(g(Yg))N$, $(g(g(Yg)))N$, \dots. It is
nevertheless possible that some \emph{other} sequence of reduction
steps does terminate in a normal form.

Take the factorial for instance. Define $\fn{Fac}$ as $Y\, \fn{Fac}'$
(i.e., a fixpoint of $\fn{Fac'}$). Then:
\begin{align*}
  \fn{Fac}\,\num 3
  &\red Y\, \fn{Fac}' \, \num 3 \\
  &\red \fn{Fac}' (Y \,\fn{Fac}') \, \num 3 \\
  &= (\lambd[x][\lambd[n][\fn{IsZero} \, n\, \num 1\,
      (\fn{Mult}\, n\, (x (\fn{Pred}\, n)))]]) \, \fn{Fac} \, \num 3\\
  & \red \fn{IsZero} \, \num 3\, \num 1\,
      (\fn{Mult}\, \num 3\, (\fn{Fac} (\fn{Pred}\, \num 3))) \\
  &\red  \fn{Mult}\, \num 3 \, (\fn{Fac} \, \num 2) 
  \intertext{Similarly,}
  \fn{Fac}\,\num 2
  &\red  \fn{Mult}\, \num 2 \, (\fn{Fac} \, \num 1) \\
  \fn{Fac}\,\num 1
  &\red  \fn{Mult}\, \num 1 \, (\fn{Fac} \, \num 0)
  \intertext{but}
  \fn{Fac}\,\num 0
  &\red \fn{Fac}' (Y \,\fn{Fac}') \, \num 0 \\
  &= (\lambd[x][\lambd[n][\fn{IsZero} \, n\, \num 1\,
      (\fn{Mult}\, n\, (x (\fn{Pred}\, n)))]]) \, \fn{Fac} \, \num 0\\
  & \red \fn{IsZero} \, \num 0\, \num 1\,
      (\fn{Mult}\, \num 0\, (\fn{Fac} (\fn{Pred}\, \num 0))) \\
  &\red \num 1
  \intertext{So together}
  \fn{Fac}\,\num 3
  &\red  \fn{Mult}\, \num 3 \,
  (\fn{Mult} \, \num 2\, (\fn{Mult} \, \num 1\, \num 1)) 
\end{align*}

The $Y$ combinator of \olref{defn:Turing-Y} is due to Alan
Turing. Alonzo Church had proposed a different version which we'll
call~$Y_C$:
\[
Y_C = \lambd[g][(\lambd[x][g(xx)])(\lambd[x][g(xx)])] \\
\]
Church's combinator is a bit weaker than Turing's in that $Yg \equiv
g(Yg)$ but not $Yg \bred g(Yg)$. Let $V$ be the term
$\lambd[x][g(xx)]$, so that $Y_C = \lambd[g][VV]$. Consider
\begin{align*}
  VV & = (\lambd[x][g(xx)])V\\
  & \red g(VV)
  \intertext{and consequently}
  (\lambd[g][VV])g & \red VV \red g(VV)\\
  g((\lambd[g][VV])g) & \red g(VV)
\end{align*}
In other words, $Yg$ and $g(Yg)$ reduce to a common term; so $Yg
\equiv_\beta g(Yg)$. This is often enough for applications.

\end{document}

