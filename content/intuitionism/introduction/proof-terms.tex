\documentclass[../../../include/open-logic-section]{subfiles}

\begin{document}
\olsection{Proof terms}

\begin{defn}[Proof terms]
  Proof terms are inductively generated by the following rules:
  \begin{enumerate}
  \item A single variable $x$ is a proof term.
  \item If $P$ and $Q$ are proof terms, then $PQ$ is also a proof
    term.
  \item If $x$ is a variable, $!A$ is a formula, and $N$ is a proof
    term, then $\lambd[\typeof{x}{!A}][N]$ is also a proof term.
  \item If $P$ and $Q$ are proof terms, then $\andi{P}{Q}$ is a proof
    term.
  \item If $M$ is a proof term, then $\ande{i}{M}$ is also a proof
    term, where $i$ is $1$ or $2$.
  \item If $M$ is a proof term, and $!A$ is a formula, then
    $\ori{i}{!A}{!M}$ is a proof term.
  \item If $M, N_1, N_2$ is proof terms, and $x_1, x_2$ are variables,
    then $\ore{M}{x_1}{N_1}{x_2}{N_2}$ is a proof term.
  \item If $M$ is a proof term and $!A$ is a formula, then
    $\falsee{!A}{M}$ is proof term.
  \end{enumerate}
\end{defn}

\begin{defn}[Typing context]
  A \emph{typing context} is a mapping from variables to formulas. We
  will call it ``context'' if there is no confusion.
\end{defn}

\begin{defn}[Typing pair]
  A \emph{typing pair} is a pair $(\Gamma, M)$,
  where $\Gamma$ is a typing context and $M$ is a proof term. Since
  in general terms only make sense with specific contexts, we would
  say ``term'' for rest of the chapter instead of ``typing pair''; and
  it will be apparent when we are talking about the literal term $M$.
\end{defn}

Intuitively speaking, a context is a set of assumptions, each
associated with a name for future references; the pair $(\Gamma, M)$
represent a derivation of a formula witnessed by $M$ with context $\Gamma$.

We now try to establish the relation between pairs and natural
deductions. First we will describe the process translating natural
deduction trees to pairs.

Consider the natural deduction tree to be translated. We will
write a proof term to the left of each formula in the tree, which
resulted in the form $M : !A$; intuitively speaking $M$ witnesses $!A$;
let's call such a form a \emph{judgment}.

First let us assign to each assumption a variable freely, with the following constraints:
\begin{enumerate}
\item Assumptions discharged in the same step (that is, with the same
  number on the square bracket) must be assigned the same variable.
\item For assumptions not discharged, assumptions of different
  formulas should be assigned different variable.
\end{enumerate}

With assumptions all associate with variables (which are terms), we can now work on the
rest of the deduction tree; we changed the natural deduction rules a
bit so that given the proof terms for premises, we can write the proof
terms for conclusion; thus we can finally assign a proof term to each
formula in the tree. Along with each group of rules is some intuitive
explanation that may help understanding.

\begin{gather*}
  \AxiomC{$M_1:!A_1$}
  \AxiomC{$M_2:!A_2$}
  \RightLabel{$\Intro{\land}$}
  \BinaryInfC{$\andi{M_1}{M_2}: !A_1 \land !A_2$}
  \DisplayProof
  \qquad
  \AxiomC{$M:!A_1 \land !A_2$}
  \RightLabel{$\Elim{\land}_i$}
  \UnaryInfC{$\ande{i}{M} : !A_i$}
  \DisplayProof
  \;
  i \in \{1,2\}
\end{gather*}

$\Intro{\land}$: assume we have  $!A_1$ witnessed by term $M_1$ and
$!A_2$ witnessed by term $M_2$, then we can pack up the two terms into a
pair $\andi{M_1}{M_2}$ which we think witnesses $!A_1 \land !A_2$.

$\Elim{\land}_i$: if we have $!A_1 \land !A_2$ witnessed by $M$, we
can extract the term witnessing $!A_i$ from the pair $M$. Note that
$M$ is not necessary of the form $\andi{M_1}{M_2}$.

Note how this coincides with the BHK interpretation. What the BHK interpretation didn't say is how we
construct the function used as proof for $!A \lif !B$.
\begin{gather*}
  \AxiomC{$\Discharge{a:!A}{}$}
  \DeduceC{$N:!B$}
  \RightLabel{$\Intro{\lif}$}
  \UnaryInfC{$\lambd[\typeof{a}{!A}][N]:!A \lif !B$}
  \DisplayProof
  \qquad
  \AxiomC{$Q:!A$}
  \AxiomC{$P:!A \lif !B$}
  \RightLabel{$\Elim{\lif}$}
  \BinaryInfC{$f a:!B$}
  \DisplayProof
\end{gather*}
The $\lambda$ notation should be understood as the same in lambda calculus,
and $f a$ means applying $f$ to $a$. 

\begin{gather*}
  \AxiomC{$M_1 : !A_1$}
  \RightLabel{$\Intro{\lor}_1$}
  \UnaryInfC{$\ori{1}{!A_2}{M_1} : !A_1 \lor !A_2$}
  \DisplayProof
  \quad
  \AxiomC{$M_2 : !A_2$}
  \RightLabel{$\Intro{\lor}_2$}
  \UnaryInfC{$\ori{2}{!A_1}{M_2}: !A_1 \lor !A_2 $}
  \DisplayProof
  \quad
  \AxiomC{$!M : A_1 \lor !A_2$}
  \AxiomC{$\Discharge{x_1 : !A_1}{}$}
  \DeduceC{$N_1 : !C$}
  \AxiomC{$\Discharge{x_2 : !A_2}{}$}
  \DeduceC{$N_2 : !C$}
  \RightLabel{$\Elim{\lor}$}
  \TrinaryInfC{$\ore{M}{x_1}{N_1}{x_2}{N_2} : !C$}
  \DisplayProof
\end{gather*}
$\ori{1}{!A_2}{M_1}$ is a term witnessing $!A_1 \lor !A_2$, where
$M_1$ witnesses $!A_1$; $A_2$ is needed to know the resulted formula.



Term $\ore{M}{x_1}{N_1}{x_2}{N_2}$ mimics the case clause in
programming languages: we already have the proof of $!A \lor !B$,
proof of $!C$ assuming $!A$, proof of $!C$ assuming $!B$, $case$ thus select the
appropriate proof depending on $M$; either way it's a proof of $!C$.

\begin{gather*}
  \AxiomC{$x : \lfalse$}
  \RightLabel{$\Elim{\lfalse}$}
  \UnaryInfC{$\falsee{!A}{x} : !A$}
  \DisplayProof
\end{gather*}
$\falsee{!A}{x}$ is a term witnessing $!A$, where $x$ is a term
witnessing $\lfalse$.


Now we have a natural deduction tree with all formulas associated with
a term, we proceed to the final step of the translation:
\begin{enumerate}
\item All assumptions not discharged are collected to build the
  context $\Gamma$.
\item Copy the bottom formula in the tree, along with the term
  assigned to it; it should be of the form $M : !A$.
\item The pair translated from the original natural deduction
  tree is $(\Gamma, M)$.
\end{enumerate}

Note how the above $\Gamma$ is well defined: since we have forbidden
assumptions of different formulas to have same variables, there won't
be any disagreement about the formulas mapped to a variable.

We now give some examples of such translation:

$\Proves ((!A \lor (!A \lif \lfalse))\lif \lfalse)\lif \lfalse$
one of its derivation is in the natural deduction section; we now
translate it into a pair:

\begin{gather*}
  \AxiomC{$\Discharge{x:!A}{1}$}
  \UnaryInfC{$\ori{1}{!A \lif \lfalse}{x} : !A \lor (!A \lif \lfalse)$}
  \AxiomC{$\Discharge{y: (!A \lor (!A \lif \lfalse))\lif \lfalse}{2}$}
  \BinaryInfC{$y (\ori{1}{!A \lif \lfalse}{x}) : \lfalse$}
  \DischargeRule{}{1}
  \UnaryInfC{$\lambd[\typeof{x}{!A}][y (\ori{1}{!A \lif \lfalse}{x})] : !A \lif \lfalse$}
  \UnaryInfC{$\ori{2}{!A}{\lambd[\typeof{x}{!A}][y (\ori{1}{!A \lif \lfalse}{x})]} : !A \lor (!A \lif \lfalse)$}
  \AxiomC{$\Discharge{y : (!A \lor (!A \lif \lfalse))\lif \lfalse}{2}$}
  \BinaryInfC{$y (\ori{2}{!A}{\lambd[\typeof{x}{!A}][y \ori{1}{!A \lif
      \lfalse}{x}])} : \lfalse$}
  \DischargeRule{}{2}
  \UnaryInfC{$\lambd[\typeof{y}{(!A \lor (!A \lif \lfalse))\lif \lfalse}][y
    (\ori{2}{!A}{\lambd[x:!A][y \ori{1}{!A \lif \lfalse}{x}]})] : ((!A \lor (!A \lif \lfalse))\lif \lfalse)\lif \lfalse$}
  \DisplayProof
\end{gather*}

The tree has no assumptions, so the context is empty; we get:
\begin{gather*}
  \Proves \lambd[\typeof{y}{(!A \lor (!A \lif \lfalse))\lif \lfalse}][y
  (\ori{2}{!A}{\lambd[x:!A][y \ori{1}{!A \lif \lfalse}{x}]})] : ((!A \lor (!A \lif \lfalse))\lif \lfalse)\lif \lfalse
\end{gather*}
If we didn't do the last discharge, the assumptions denoted by $y$
would be in context and we would get:
\begin{gather*}
  y: ((!A \lor (!A \lif \lfalse))\lif \lfalse) \Proves y
    (\ori{2}{!A}{\lambd[x:!A][y \ori{1}{!A \lif \lfalse}{x}]}) : \lfalse
  \end{gather*}

  Another example:$\Proves !A \lif (!A \lif \lfalse) \lif \lfalse$
\begin{gather*}
  \AxiomC{$\Discharge{x:!A}{2}$}
  \AxiomC{$\Discharge{y:!A \lif \lfalse}{1}$}
  \BinaryInfC{$y x : \lfalse$}
  \DischargeRule{}{1}
  \UnaryInfC{$\lambd[\typeof{y}{!A \lif \lfalse}][y x]:(!A \lif \lfalse)\lif \lfalse$}
  \DischargeRule{}{2}
  \UnaryInfC{$\lambd[\typeof{x}{!A}][\lambd[\typeof{y}{!A \lif \lfalse}][y x]] : !A \lif (!A \lif \lfalse) \lif \lfalse$}
  \DisplayProof
\end{gather*}
Again all assumptions are discharged thus the context is empty, the
resulted term is
\begin{gather*}
  \Proves \lambd[\typeof{x}{!A}][\lambd[\typeof{y}{!A \lif \lfalse}][y x]] : !A \lif (!A \lif \lfalse) \lif \lfalse
\end{gather*}
If we didn't do the last two discharge, the assumptions denoted
by both $x$ and $y$ would be in context and we would get
\begin{gather*}
  x:!A, y:!A \lif \lfalse \Proves y x : \lfalse
\end{gather*}

Now let us consider the other direction: translating terms back to
natural deduction trees. Let us still use the double refutation of 
the excluded middle as example, and let $S$ denote this term.

Before we get started, we shall note that, for each natural deduction rule, the term in the conclusion is always formed by
wrapping some operator around the terms in the premises. For
example, from the structure of the $S$ we infer that the last rule
applied must be $\Intro{\lif}$. In general we can recover the
skeleton solely by the structure of the term, like follows:
\begin{gather*}
  \AxiomC{$\Discharge{x}{1}$}
  \UnaryInfC{$\ori{1}{!A \lif \lfalse}{x} : $}
  \AxiomC{$\Discharge{y: }{2}$}
  \BinaryInfC{$y (\ori{1}{!A \lif \lfalse}{x}) : $}
  \DischargeRule{}{1}
  \UnaryInfC{$\lambd[\typeof{x}{!A}][y (\ori{1}{!A \lif \lfalse}{x})] : $}
  \UnaryInfC{$\ori{2}{!A}{\lambd[\typeof{x}{!A}][y (\ori{1}{!A \lif \lfalse}{x})]} : $}
  \AxiomC{$\Discharge{y: }{2}$}
  \BinaryInfC{$y (\ori{2}{!A}{\lambd[\typeof{x}{!A}][y \ori{1}{!A \lif \lfalse}{x}]}): $}
  \DischargeRule{}{2}
  \UnaryInfC{$\lambd[\typeof{y}{(!A \lor (!A \lif \lfalse))\lif \lfalse}][y
    (\ori{2}{!A}{\lambd[\typeof{x}{!A}][y \ori{1}{!A \lif \lfalse}{x}]})]$}
  \DisplayProof
\end{gather*}

The applied rules  are not noted but it should be obvious; our next
step is thus to recover the formulas these terms witnessing. Here is
the basic idea: let $F(\Gamma,M)$ denote the formula witnessed by
$M$ with context $\Gamma$, which is inductively defined on $M$ as follows:
\begin{align*}
  F(\Gamma, x) &= \Gamma(x) \\
  F(\Gamma, \lambd[\typeof{x}{!A}][N]) &= !A \lif F(\Gamma \cup
  \{x:!A\}, N) \\
  F(\Gamma, \ore{M}{x_1}{N_1}{x_2}{N_2}) &= F(\Gamma \cup
  \{x_i:F(\Gamma, M)_i\}, N_i) 
\end{align*}
where $\Gamma(x)$ means the formula mapped to by $x$ in $\Gamma$.
Other easier cases are left to the reader; and $\Gamma \cup \{x:!A\}$
is a context exactly same as $\Gamma$ except mapping $x$ to $!A$,
whether or not $x$ is already in $\Gamma$.

Note there are cases where $F(\Gamma, M)$ is not defined, for example:
\begin{enumerate}
\item In the first line, it is possible that $x$ is not in $\Gamma$.
\item In recursive cases, the inner invocation may be undefined, making
  the outer one undefined too.
\item In the third line, it's only defined when $F(\Gamma, M)$ is of
  the form $!A_1 \lor !A_2$, and the right hand is independent on $i$.
\end{enumerate}

Note how the the recursive function invocation tree coincide with the natural
deduction tree: try $F(\Gamma, M)$ and we will find every invocation
of $F$ corresponds to a term in the tree of $M$, and the returned
value is the formula witnessed by that term. That's it: for the pair
$(\Gamma, M)$ simply call $F(\Gamma, M)$ and the resulted invocation
tree is the corresponding natural deduction tree.

It's obvious that if we translate a natural deduction to a
typing pair and translate it back to natural deduction, it remains the
same; the proof is left to the reader.

In the other direction, if we first translate a typing pair to natural
deduction and then translate it back, we won't necessarily get the
same pair back; for example, consider the pair $(x:!A, y:!A \lif !B, y x)$,
translating it forth and back we may get $(a:!A, b:!A \lif !B, b a)$,
or $(x:!A, a:!A \lif !B, a x)$, etc. But there is apparently some
relation among these pairs and we can consider them in the same class.
It's not exactly the alpha equivalence class we introduced in untyped
lambda calculus since we are talking about pairs instead of
barely terms, but the intuition is similar.

Now we have established the correspondence between typing pairs and
natural deduction, we would be able to proves theorems for typing
pairs and transfer it to natural deductions. In the rest of the
chapter we will be using this technique extensively.

Similar to what we did in the natural deduction section, we can make
some observations here too. Let $\Gamma \Proves M:!A$ denote that
there is a pair $(\Gamma, M)$ witnessing the formula $!A$. We can have
the following observations:

\begin{gather*}
  \AxiomC{$\Gamma \Proves M_1:!A_1$}
  \AxiomC{$\Delta \Proves M_2:!A_2$}
  \RightLabel{$\Intro{\land}$}
  \BinaryInfC{$\Gamma,\Delta \Proves \tuple{M_1,M_2} : !A_1 \land !A_2 $}
  \DisplayProof
  \quad
  \AxiomC{$\Gamma \Proves M:!A_1 \land !A_2$}
  \RightLabel{$\Elim{\land}_i$}
  \UnaryInfC{$\Gamma \Proves \ande{i}{M} : !A_i$}
  \DisplayProof
  \\
  \AxiomC{$\Gamma \Proves M_1: !A_1$}
  \RightLabel{$\Intro{\lor}_1$}
  \UnaryInfC{$\Gamma \Proves \ori{1}{!A_2}M :  !A_1 \lor !A_2$}
  \DisplayProof
  \quad
  \AxiomC{$\Gamma \Proves M_2: !A_2$}
  \RightLabel{$\Intro{\lor}_2$}
  \UnaryInfC{$\Gamma \Proves \ori{2}{!A_1}M :  !A_1 \lor !A_2$}
  \DisplayProof
  \\
  \AxiomC{$\Gamma \Proves M : !A \lor !B$}
  \AxiomC{$\Delta_1, x_1: !A_1 \Proves N_1 : !C$}
  \AxiomC{$\Delta_2, x_2: !A_2 \Proves N_2 : !C$},
  \RightLabel{$\Elim{\lor}$}
  \TrinaryInfC{$\Gamma, \Delta, \Delta' \Proves \ore{M}{x_1}{N_1}{x_2}{N_2} : !C$}
  \DisplayProof
  \\
  \AxiomC{$\Gamma, x : !A \Proves N : !B$}
  \RightLabel{\Intro{\lif}}
  \UnaryInfC{$\Gamma \Proves \lambd[\typeof{x}{!A}][N] : !A \lif !B$}
  \DisplayProof
  \quad
  \AxiomC{$\Gamma \Proves Q : !A$}
  \AxiomC{$\Delta \Proves P : !A \lif !B$}
  \RightLabel{\Elim{\lif}}
  \BinaryInfC{$\Gamma, \Delta \Proves P Q : !B$}
  \DisplayProof
  \\
  \AxiomC{$\Gamma \Proves M : \lfalse$}
  \RightLabel{\Elim{\lfalse}}
  \UnaryInfC{$\Gamma  \Proves \falsee{!A}{M} : !A$}
  \DisplayProof
\end{gather*}

The reader may have seen these before if s/he have some
familiarity with type theory: the above observations are
exactly, word for word, the typing rules spelled out. More
specifically, the typing rules of simply typed lambda calculus
extended with product, sum and bottom.

In addition, the $F(\Gamma, M)$ function we defined above is actually
a type checking algorithm; it returns the type of the term with the
context, or is undefined if the term is ill-typed with the context.

Historically type theory and intuitionistic logic were developed
separately at first, until some scholars discovered the
correspondence, which is nowadays called ``proposition as types'' or
``Curry-Howard correspondence'', pointing out, among others, the following
correspondences:
\begin{center}
  \begin{tabular}{c c c}
    logic & program \\
    \hline
    proposition & type \\
    proof & term \\
    assumption & variable \\
    discharged assumption & bind variable \\
    not discharged assumption & free variable \\
    implication & function type \\
    conjunction & product type \\
    disjunction & sum type \\
    absurdity & bottom type \\
    \hline
  \end{tabular}
\end{center}

This correspondence is one of the cornerstone of many proof assistants
used today, since checking a proof witnessing a proposition (as we did above) is no different from checking a
program (term) meeting the declared type, program and proof are interchangeable: in Agda, users
write programs converting proofs to prove a proposition; Coq also allows uses to write tactics
which is commands that can do some low-level proof transformation.

In this chapter, however, type theory will only be treated as a more
compact syntax of natural deduction, and used extensively in
propositions and proofs.
\end{document}
