\documentclass[../../../include/open-logic-section]{subfiles}

\begin{document}

\olsection{Reduction}

Sometimes we may find some detour in our derivation tree, for
instance:
\begin{gather*}
  \AxiomC{$!A$}
  \AxiomC{$!A \lif !B$}
  \RightLabel{$\Elim{\lif}$}
  \BinaryInfC{$!B$}
  \AxiomC{$\Discharge{!C}{}$}
  \RightLabel{$\Intro{\land}$}
  \BinaryInfC{$!B \land !C$}
  \RightLabel{$\Elim{\land}$}
  \UnaryInfC{$!B$}
  \RightLabel{$\Intro{\lif}$}
  \UnaryInfC{$!C \lif !B$}
  \DisplayProof
\end{gather*}
A more efficient derivation is:
\begin{gather*}
  \AxiomC{$!A$}
  \AxiomC{$!A \lif !B$}
  \RightLabel{$\Elim{\lif}$}
  \BinaryInfC{$!B$}
  \RightLabel{$\Intro{\lif}$}
  \UnaryInfC{$!C \lif !B$}
  \DisplayProof
\end{gather*}

As we can see, $\Intro{\land}$ followed by  
$\Elim{\land}$ is ``cancelled out'' together. In general we shall note
that the conclusion of $\Elim{\land}$ is always the formula on one side
of the conjunction, and the premises of $\Intro{\land}$ requires both
sides of the conjunction, thus if we need a derivation of either side,
we can simply use that derivation without introducing the conjunction followed by
eliminating it.

Thus in general we shall see:
\begin{gather*}
  \AxiomC{}
  \RightLabel{\Deduce{D}[1]}
  \DeduceC{$!A_1$}
  \AxiomC{}
  \RightLabel{\Deduce{D}[2]}
  \DeduceC{$!A_2$}
  \RightLabel{$\Intro{\land}$}
  \BinaryInfC{$!A_1 \land !A_2$}
  \RightLabel{$\Elim{\land}_i$}
  \UnaryInfC{$!A_i$}
  \DisplayProof
  \quad
  \redone
  \quad
  \AxiomC{}
  \RightLabel{\Deduce{D}[i]}
  \DeduceC{$!A_i$}
  \DisplayProof
\end{gather*}

The $\redone$ symbol has the same meaning as in lambda calculus, which is a
single step of reduction. As we have said, we intend proof terms as a
more compact syntax; the above reduction rule thus becomes:
\begin{gather*}
  (\Gamma, p_i \tuple{\typeof{M_1}{!A_1}, \typeof{M_2}{!A_2}}) \redone
  (\Gamma, M_i)
\end{gather*}
in type theory this is the beta reduction rule for product type.

Note the type annotation on $M_1$ and $M_2$: while in the standard term
syntax only $\lambd[\typeof{x}{!A}][N]$ has such notion, we reuse the
notion here to remind the reader of the formula the term associated
with in the corresponding natural deduction tree, to reveal the
correspondence between the two syntax.

In natural deduction, such a pair of derivations on the left that's subject to cancelling is called a
\emph{cut}; correspondingly, in type theory the term to the left of
$\redone$ is called a \emph{redex}, and the term to the right is
called a \emph{reductum}. Unlike untyped lambda
calculus, where only $(\lambd[x][N])Q$ is considered to be
redex, in type theory the syntax is extended as needed and the added
syntax amazingly has very similar properties as lambda, include
the availability of reduction, as we will see.

Similarly we have reduction for disjunction:
\begin{gather*}
  \AxiomC{}
  \RightLabel{\Deduce{D}}
  \DeduceC{$!A_i$}
  \RightLabel{$\Intro{\lor}$}
  \UnaryInfC{$!A_1 \lor !A_2$}
  \AxiomC{$\Discharge{!A_1}{u}$}
  \RightLabel{\Deduce{D}[1]}
  \DeduceC{$!C$}
  \AxiomC{$\Discharge{!A_2}{u}$}
  \RightLabel{\Deduce{D}[2]}
  \DeduceC{$!C$}
  \DischargeRule{$\Elim{\lor}$}{u}
  \TrinaryInfC{$!C$}
  \DisplayProof
  \quad
  \redone
  \quad
  \AxiomC{}
  \RightLabel{\Deduce{D}}
  \DeduceC{$!A_i$}
  \RightLabel{\Deduce{D}[i]}
  \DeduceC{$!C$}
  \DisplayProof
\end{gather*}
reduction in proof term syntax:
\begin{gather*}
  (\Gamma, \ore{\ori{i}{!A_{\bar{i}}}{\typeof{M}{!A_i}}}{\typeof{x_1}{!A_1}}{\typeof{N_1}{!C}}
  {\typeof{x_2}{!A_2}}{\typeof{N_2}{!C}}) \redone (\Gamma, \Subst{\typeof{N_i}{!C}}{\typeof{M}{!A_i}}{\typeof{x_i}{!A_i}})
\end{gather*}
in type theory this is called the beta reduction rule of sum types.
The notion $\Subst{M}{N}{x}$ intuitively means replacing all
assumptions denoted by variable $x$ in $M$ with $N$, 

It would be nice if we pass the context $\Gamma$ to the substitution
function so that it can check if the substitution makes sense at all.
For example, $\Subst{x y}{a b}{y}$ does not make sense under the
context $\{x:!A \lif !D, y:!A, a:!B\lif !C, b:!B\}$ since we are plugging in a proof
of $!C$ where $!A$ is expected. However, as long as our usage of
substitution is careful enough to avoid such error, we don't have to worry about
such things. Thus we can define it recursively as we did for untyped
lambda calculus as if we are dealing with untyped terms. The concrete
definition is left to the reader; After the definition it should be
proved that the above reduction relation indeed reflects the deduction
version of reduction relation.

And finally the reduction of function type:
\begin{gather*}
  \AxiomC{$\Discharge{!A}{u}$}
  \RightLabel{\Deduce{D}}
  \DeduceC{$!B$}
  \DischargeRule{$\Intro{\lif}$}{u}
  \UnaryInfC{$!A \lif !B$}
  \AxiomC{}
  \RightLabel{\Deduce{D'}}
  \DeduceC{$!A$}
  \RightLabel{$\Elim{\lif}$}
  \BinaryInfC{$!B$}
  \DisplayProof
  \quad
  \redone
  \quad
  \AxiomC{}
  \RightLabel{\Deduce{D'}}
  \DeduceC{$!A$}
  \RightLabel{\Deduce{D}}
  \DeduceC{$!B$}
  \DisplayProof
\end{gather*}
\begin{gather*}
  (\Gamma, (\lambd[\typeof{x}{!A}][\typeof{N}{!B}])\typeof{Q}{!A})
  \redone (\Gamma, \Subst{\typeof{N}{!B}}{\typeof{Q}{!A}}{\typeof{x}{!A}})
\end{gather*}

Absurdity has only elimination rule and no introduction rule, thus
there is no such reduction for it.

Note that the above notion of reduction concerns only deductions with
cut at bottom, we would of course like to extend it to deductions with
cuts at any position. Note that, however, the conclusion of the
reduction does not change after reduction, thus we are free to
continue applying rules to both sides of $\redone$, the resulted pairs
of trees being our extended notion of reduction; it is analogous
to compatibility in untyped lambda calculus.

It's easy to see that the context $\Gamma$ does not change during the
reduction (both the original and the extended version), thus it's unnecessary to mention the
context when we are discussing reductions. In the rest of the chapter
we would assume that every term is accompanied by a context which
does no change during reduction; and when we say ``proof term'', we
mean a proof term accompanied by a context which make it well typed.

As in lambda calculus, the notion of normal-form term and normal
deduction is given:
\begin{defn}
  A proof term with no redex is said to be in \emph{normal form};
  likewise, a derivation tree with no cut is said to be \emph{normal
    deduction}. Apparently, a proof term is in normal form if and only
  if its counterpart derivation tree is a normal deduction.
\end{defn}
\end{document}