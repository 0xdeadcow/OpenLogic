% Part: computability
% Chapter: tm-computations
% Section: turing-machines

\documentclass[../../include/open-logic-section]{subfiles}

\begin{document}

\olfileid{cmp}{tur}{tur}
\olsection{Turing Machines}

\begin{explain}
The formal definition of what constitutes a Turing machine looks
abstract, but is actually simple: it merely packs into one
mathematical !!{structure} all the information needed to specify the
workings of a Turing machine. This includes (1) which states the
machine can be in, (2) which symbols are allowed to be on the tape, (3)
which state the machine should start in, and (4) what the instruction
set of the machine is.
\end{explain}

\begin{defn}
A \emph{Turing machine} $T = \langle Q, \Sigma, s, I\rangle$ consists of
\begin{enumerate}
\item a finite set of states $Q$,
\item a finite alphabet $\Sigma$ which includes $\TMendtape$ and
  $\TMblank$,
\item an initial state $s \in Q$,
\item a finite instruction set~$I \subseteq Q \times \Sigma \times Q
  \times \Sigma \times \{\TMleft, \TMright, \TMstay\}$.
\end{enumerate}
\end{defn}

\begin{explain}
We assume that the tape is infinite in one direction only. For this
reason it is useful to designate a special symbol~$\TMendtape$ as
a marker for the left end of the tape. This makes it easier for
Turing machne programs to tell when they're ``in danger'' of running
off the tape. 

Classical Turing machines make use of only two symbols: $\TMblank$ and
$\TMstroke$. While it is common to consider Turing machines that use additional
symbols, no extra computing power is gained by this. Anything computable by
a Turing machine is computable by a classical Turing machine. Other
definitions of Turing machines are possible,
including one where the tape is infinite in both directions. In such cases,
the marker for the left end of the tape is not necessary.
\end{explain}

\begin{ex}
Although it is possible to represent Turing machines using only formal
definitions, it is useful to have a visual representation of the
machines. Such visual, or diagrammatic, representations of Turing
machines are called \emph{state diagrams}. The diagrams are composed of
state cells connected by arrows. Unsurprisingly, each state cell represents
a state of the machine. Each arrow represents an instruction that can be
carried out from that state. The specifics of the instruction are written above
the appropriate arrow. Consider the following machine, which has only two
states and one instruction:


The instruction can be read as \emph{if reading a blank in
state $q_0$, write a stroke, move right, and go to state $q_1$}. This is
equivalent to the instruction $\tuple{q_0, \TMblank, q_1, \TMstroke, 
\TMright}$.
\end{ex}

\begin{ex}
Throughout the chapter we will present several examples of Turing machines
and their computing power. Although fairly simple in configuration,
Turing machines can compute anything a regular computer can compute. 
We will start with a simple machine, one that reads the input on a tape and 
accepts it (i.e., halts) if, and only if, it is of a certain form. Specifically, this 
machine reads a block of strokes and halts if, and only if, there is an even 
number of strokes on the tape. We call it an \emph{even machine}:
\[
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,
                    semithick]
  \tikzstyle{every state}=[fill=none,draw=black,text=black]

  \node[state]         (A)                     {$q_1$};
  \node[state]         (B) [right of=A] {$q_2$};

  \path (A) edge                      node {1,1,R} (B)
            (B) edge [loop above] node {0,0,R} (B)
                  edge                      node {1,1,R} (A);
\end{tikzpicture}
\]
\end{ex}

\begin{ex}
The above machine halts only when the input is an even number of strokes.
Otherwise, the machine (theoretically) continues to operate until infinity. 

Not all machines will halt. If we concepualize halting as the machine running
out of instructions to execute, then we can create a machine that never halts
simply by ensuring that there is an outgoing arrow for each symbol at each
state cell. The above machine can be modified to run infnitely by adding an
instruction for scanning a blank at~$q_1$. The following machine never halts:

\[
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,
                    semithick]
  \tikzstyle{every state}=[fill=none,draw=black,text=black]

  \node[state]         (A)                     {$q_1$};
  \node[state]         (B) [right of=A] {$q_2$};

  \path (A) edge                      node {1,1,R} (B)
                  edge [loop above] node {0,0,R} (A)
            (B) edge [loop above] node {0,0,R} (B)
                  edge                      node {1,1,R} (A);
\end{tikzpicture}
\]
\end{ex}

\begin{explain}
Machine tables are another way of representing Turing machines. Machine
tables havethe tape alphabet displayed on the x-axis, and the set of machine
states across the y-axis. Inside the table, at the intersection of each state
 and symbol is written the rest of the instruction - the new state, new symbol,
 and direction of movement. Machine tables make it easy to determine in what 
 state, and for what symbol, the machine halts. Whenever
there is a gap in the table is a possible point for the machine to halt. Unlike
state diagrams and instruction sets, where the points at which the machine halts
are not always immediately obvious, any halting points are quickly identified by 
finding the gaps in the machine table.
\end{explain}

\begin{ex}
The machine table for the even machine is:
\centering
\begin{tabular}{lllll}
           & $\TMblank$ & $\TMstroke$ &  &  \\
$q_1$ &  & $\TMstroke, q_2, \TMright$         &  &  \\
$q_2$ &            &             &  &  \\
     &            &             &  & 
\end{tabular}
\end{ex}

\begin{ex}
We can easily convert between the different forms of representation.
For example, the following are three different ways of specifying the
doubling machine:
\end{ex}

\begin{ex}
So far we have only considered machines that read input, and have not 
given any thought to machines that both read and write. An example of
such a machine (although there are many, many examples) is a \emph{doubler}.
A doubler, when started with a block of~$n$ strokes on the tape, outputs
a block of~$2n$ strokes.

Before building such a machine, it is important to come up with a 
\emph{strategy} for solving the problem. Since the machine, as we have 
formulated it, cannot remember how many strokes it has read, we need to
come up with a way to ensure that we are keeping track of all the strokes
on the tape. One such way is to erase the first stroke from the input, then
traverse over all the others, leaving a blank, and writing two new strokes.
The machine will then go back and find the second stroke in the input, and
double that one as well. By repeating this process until there are no more
strokes left from the original input, the machine has successfully doubled
the input. Here is one such formualtion of the machine:
\[
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,
                    semithick]
  \tikzstyle{every state}=[fill=none,draw=black,text=black]

  \node[state]         (1)                     {$q_1$};
  \node[state]         (2) [right of=1] {$q_2$};
  \node[state]         (3) [right of=2] {$q_3$};
  \node[state]         (4) [below of=3] {$q_4$};
  \node[state]         (5) [left of=4]       {$q_5$};
  \node[state]         (6) [left of=5]       {$q_6$};

  \path (1) edge              node {1,0,R} (2)
            (2) edge [loop above] node {1,1,R} (2)
                 edge              node {0,0,L} (3)
            (3) edge [loop above] node {1,1,R} (3)
                 edge  node {0,1,R} (4)
            (4) edge [loop below] node {0,1,L} (4)
                 edge              node {1,1,L} (5)
            (5) edge [loop below]  node {1,1,L} (5)
                 edge              node {0,0,L} (6)
            (6) edge [loop below] node {1,1,L} (6)
                 edge              node {0,0,R} (1);
\end{tikzpicture}
\]
\end{ex}

\begin{prob}
Choose an arbitary input and trace through the configurations of the
above machine.
\end{prob}

\begin{prob}
Come up with a new method for solving the doubler problem, then build
a machine that executes your method. Check that your machine works by
tracing through the configurations with two different inputs.
\end{prob}

\end{document}
