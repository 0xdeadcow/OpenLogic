% Part: first-order-logic
% Chapter: syntax-and-semantics
% Section: first-order-languages

\documentclass[../../include/open-logic-section]{subfiles}

\begin{document}

\olfileid{fol}{syn}{fol}

\olsection{First-Order Languages}


Expressions of first-order logic are built up from a basic vocabulary
containing \emph{!p{variable}}, \emph{!p{constant}},
\emph{!p{predicate}} and sometimes \emph{!p{function}}.  From them,
together with logical connectives, quantifiers, and punctuation
symbols such as parentheses and commas, \emph{terms} and
\emph{!p{formula}} are formed.

\begin{explain}
Informally, !p{predicate} are names for properties and relations,
!p{constant} are names for individual objects, and !p{function} are names
for mappings.  These, except for the !!{identity}~$\eq$, are the
\emph{non-logical symbols} and together make up a language.  Any
first-order language~$\Lang L$ is determined by its non-logical
symbols.  In the most general case, $\Lang L$ contains infinitely
many symbols of each kind.
\end{explain}

In the general case, we make use of the following symbols in
first-order logic:

\begin{enumerate}
\item Logical symbols
\begin{enumerate}
\item Logical connectives:
  \startycommalist
  \printtag{notprvNot}{}{\ycomma $\lnot$ (negation)}%
  \printtag{notprvAnd}{}{\ycomma $\land$ (conjunction)}%
  \printtag{notprvOr}{}{\ycomma $\lor$ (disjunction)}%
  \printtag{notprvIf}{}{\ycomma $\lif$ (!!{conditional})}%
  \printtag{notincIff,notprvIff}{}{\ycomma $\liff$ (!!{biconditional})}%
  \printtag{notprvAll}{}{\ycomma $\lforall$ (universal quantifier)}%
  \printtag{notprvEx}{}{\ycomma $\lexists$ (existential quantifier)}.
\printtag{notincFalse,notprvFalse}{}{%
\item The propositional constant for !!{falsity}~$\lfalse$.}
\printtag{notincTrue,notprvTrue}{}{%
\item The propositional constant for !!{truth}~$\ltrue$.}
\item The two-place !!{identity}~$\eq$.
\item A !p{denumerable} set of !p{variable}: $\Obj v_0$, $\Obj v_1$, $\Obj
  v_2$, \dots
\end{enumerate}
\item Non-logical symbols, making up the \emph{standard
  language} of first-order logic
\begin{enumerate}
\item A !p{denumerable} set of $n$-place !p{predicate} for each $n>0$: $\Obj
  A^n_0$, $\Obj A^n_1$, $\Obj A^n_2$, \dots
\item A !p{denumerable} set of !p{constant}: $\Obj c_0$, $\Obj c_1$, $\Obj
  c_2$, \dots.
\item A !p{denumerable} set of $n$-place !p{function} for each $n>0$:
  $\Obj f^n_0$, $\Obj f^n_1$, $\Obj f^n_2$, \dots
\end{enumerate}
\item Punctuation marks: (, ), and the comma.
\end{enumerate}

\printtag{definedSyms}{%
In addition to the primitive connectives and
\printtag{notprvEx,notprvAll}{quantifier}{quantifiers} introduced
above, we also use the following \emph{defined} symbols:
\startycommalist
  \printtag{prvNot}{}{\ycomma $\lnot$ (negation)}%
  \printtag{prvAnd}{}{\ycomma $\land$ (conjunction)}%
  \printtag{prvOr}{}{\ycomma $\lor$ (disjunction)}% 
  \printtag{prvIf}{}{\ycomma $\lif$ (!!{conditional})}% 
  \printtag{notincIff,prvIff}{}{\ycomma $\liff$ (!!{biconditional})}%
  \printtag{prvAll}{}{\ycomma $\lforall$ (universal quantifier)}%
  \printtag{prvEx}{}{\ycomma $\lexists$ (existential quantifier)}%
  \printtag{notincFalse,prvFalse}{}{\ycomma !!{falsity}~$\lfalse$}%
  \printtag{notincTrue,prvTrue}{}{\ycomma !!{truth}~$\ltrue$}}.

\begin<definedSyms>{explain}
A defined symbol is not officially part of the language, but is
introduced as an informal abbreviation: it allows us to abbreviate
formulas which would, if we only used primitive symbols, get quite
long.  This is obviously an advantage.  The bigger advantage, however,
is that proofs becme shorter.  If a symbol is primitive, it has to be
treated separately in proofs. The more primitive symbols, therefore,
the longer our proofs.
\end{explain}

% Alternate symbols

\begin{intro}
You may be familiar with different terminology and symbols than the
ones we use above. Logic texts (and teachers) commonly use either
$\sim$, $\neg$, and~! for ``negation'', $\wedge$, $\cdot$, and $\&$
for ``conjunction''.  Commonly used symbols for the ``conditional'' or
``implication'' are $\rightarrow$, $\Rightarrow$, and $\supset$.
\printtag{incIff}{Symbols for ``biconditional,'' ``bi-implication,''
  or ``(material) equivalence'' are $\leftrightarrow$,
  $\Leftrightarrow$, and $\equiv$.}{} 
\printtag{incFalse}{The $\lfalse$ symbol is variously called
  ``falsity,'' ``falsum,'', ``absurdity,'', or ``bottom.''}{}
\printtag{incTrue}{The $\ltrue$ symbol is variously called
  ``truth,'' ``verum,'', or ``top.''}{}

It is very common to use lower case letters (e.g., $a$, $b$, $c$) from
the beginning of the Latin alphabet for !p{constant} (sometimes called
names), and lower case letters from the end (e.g., $x$, $y$, $z$) for
!p{variable}. Quantifiers combine with !p{variable}, e.g., $x$;
notational variations include $\forall x$, $(\forall x)$, $(x)$, $\Pi x$,
$\bigwedge_x$ for the universal quantifier and $\exists x$, $(\exists
x)$, $(Ex)$, $\Sigma x$, $\bigvee_x$ for the existential quantifier.
\end{intro}

\begin{explain}
We are treating the propositional operators and both quantifiers as
primitive symbols of the language. We might instead choose a smaller
stock of primitive symbols and treat the other !p{operator} as
defined. ``Truth functionally complete'' sets of Boolean operators
include $\{ \lnot, \lor \}$, $\{ \lnot, \land \}$, and $\{ \lnot,
\lif\}$ --- these can be combined with either quantifier for an
expressively complete first-order language.

You may be familiar with two other !p{operator}: the Sheffer
stroke, $\uparrow$ (named after Henry Sheffer), and Peirce's arrow
$\downarrow$, also known as Quine's dagger. When given their usual
readings of ``nand'' and ``nor'' (respectively), these operators are
truth functionally complete by themselves.
\end{explain}

\end{document}
