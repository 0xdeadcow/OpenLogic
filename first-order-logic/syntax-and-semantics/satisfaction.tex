% Part: first-order-logic
% Chapter: syntax-and-semantics
% Section: satisfaction

\documentclass[../../include/open-logic-section]{subfiles}

\begin{document}

\olfileid{fol}{syn}{sat}
\olsection{Satisfaction of a !!^{formula} in a !!^{structure}}

\begin{explain}
The basic notion that relates expressions such as terms and
!!{formula}s, on the one hand, and !!{structure}s on the other, are
those of \emph{denotation} and \emph{satisfaction}.  Informally, a
term \emph{denotes} an element of a !!{structure}---if the term is
just a constant, it denotes the object assigned to the constant by the
!!{structure}, and if it is built up using !!{function}s, the
denotation is computed from the values of constants and the functions
assigned to the functions in the term.  A !!{formula} is
\emph{satisfied} in a !!{structure} if the interpretation given to the
predicates makes the !!{formula} true in the domain of the
!!{structure}. This notion of satisfaction is specified inductively:
the specification of the !!{structure} directly states when atomic
!!{formula}s are satisfied, and we define when a complex !!{formula} is
satisfied depending on the main connective or quantifier and whether
or not the immediate !!{subformula}s are satisfied. The case of the
quantifiers here is a bit tricky, as the immediate !!{subformula} of a
quantified !!{formula} has a free !!{variable}, and !!{structure}s
don't specify what !!{variable}s denote.  In order to deal with this
difficulty, we also introduce \emph{variable assignments} and define
satisfaction not with respect to a !!{structure} alone, but with
respect to a !!{structure} plus a !!{variable} assignment.
\end{explain}

\begin{defn}[Variable Assignment]
A \emph{variable assignment}~$s$ for a !!{structure}~$\Struct{M}$ is a
function which maps each !!{variable} to an element of~$\Domain M$,
i.e., $s\colon \Var \to \Domain M$.
\end{defn}

\begin{defn}[Denotation of Terms]
If $t$ is a term of the language~$\Lang L$, $\Struct M$ is a
!!{structure} for~$\Lang L$, and $s$ is a !!{variable} assignment
for~$\Struct M$, the \emph{denotation}~$\Value{t}{M}[s]$ is defined as
follows:
\begin{enumerate}
\item \indcase{t}{c}{$\Value{\indfrm}{M}[s] = \Assign{\indcomplex}{M}$.}
\item \indcase{t}{x}{$\Value{\indfrm}{M}[s] = s(\indcomplex)$.}
\item \indcase{t}{\Atom{f}{t_1, \ldots, t_n}}{
\[
\Value{\indfrm}{M}[s] = \Assign{f}{M}(\Value{t_1}{M}[s], \ldots,
\Value{t_n}{M}[s]).
\]}
\end{enumerate}
\end{defn}

\begin{defn}[$x$-Variant]
If $s$ is a !!{variable} assignment for a !!{structure}~$\Struct M$, then any
!!{variable} assignment $s'$ for $\Struct M$ which differs from $s$ only
in what it assigns to $x$ is called an \emph{$x$-variant} of~$s$.  If
$s'$ is an $x$-variant of $s$ we write $s \sim_x s'$.
\end{defn}

\begin{defn}[Satisfaction]
Satisfaction of a !!{formula}~$!A$ in a !!{structure}~$\Struct M$
relative to a !!{variable} assignment~$s$, in symbols:
$\Sat{M}{!A}[s]$, is defined recursively as follows. (We write
$\Sat/{M}{!A}[s]$ to mean ``not $\Sat{M}{!A}[s]$.'')
\begin{enumerate}
\tagitem{prvFalse}{%
  \indcase{!A}{\lfalse}{not $\Sat{M}{\indfrm}[s]$.}}{}

\tagitem{prvTrue}{%
  \indcase{!A}{\ltrue}{$\Sat{M}{\indfrm}[s]$.}}{}

\item \indcase{!A}{\Atom{R}{t_1, \dots, t_n}}{$\Sat{M}{\indfrm}[s]$
  iff $\langle \Value{t_1}{M}[s], \dots, \Value{t_n}{M}[s] \rangle \in
  \Assign{R}{M}$.}

\item \indcase{!A}{\eq[t_1][t_2]}{$\Sat{M}{\indfrm}[s]$ iff
  $\Value{t_1}{M}[s] = \Value{t_2}{M}[s]$.}

\tagitem{prvNot}{% 
  \indcase{!A}{\lnot !B}{$\Sat{M}{\indfrm}[s]$ iff
    $\Sat/{M}{!B}[s]$.}}{}

\tagitem{prvAnd}{%
  \indcase{!A}{(!B \land !C)}{$\Sat{M}{\indfrm}[s]$ iff $\Sat{M}{!B}[s]$
    and $\Sat{M}{!C}[s]$.}}{}

\tagitem{prvOr}{%
  \indcase{!A}{(!B \lor !C)}{$\Sat{M}{\indfrm}[s]$ iff
    $\Sat{M}{!A}[s]$ or $\Sat{M}{!B}[s]$ (or both).}}{}

\tagitem{prvIf}{%
  \indcase{!A}{(!B \lif !C)}{$\Sat{M}{\indfrm}[s]$ iff $\Sat/{M}{!B}[s]$
    or $\Sat{M}{!C}[s]$ (or both).}}{}

\tagitem{prvIff}{% 
  \indcase{!A}{(!B \lif !C)}{$\Sat{M}{\indfrm}[s]$ iff either both
    $\Sat{M}{!B}[s]$ and $\Sat{M}{!C}[s]$, or neither $\Sat{M}{!B}[s]$
    nor $\Sat{M}{!C}[s]$.}}{}

\tagitem{prvAll}{%
  \indcase{!A}{\lforall[x][!B]}{$\Sat{M}{\indfrm}[s]$ iff for every
    $x$-variant $s'$ of $s$, $\Sat{M}{!B}[s']$.}}{}

\tagitem{prvEx}{% 
  \indcase{!A}{\lexists[x][!B]}{$\Sat{M}{\indfrm}[s]$ iff there is an
    $x$-variant $s'$ of $s$ so that $\Sat{M}{!B}[s']$.}}{}
\end{enumerate}
\end{defn}

\begin{explain}
A !!{variable} assignment~$s$ provides a value for \emph{every} variable in
the language. This is of course not necessary: whether or not a
!!{formula}~$!A$ is satisfied in a !!{structure} with respect to~$s$ only
depends on the assignments~$s$ makes to the free !!{variable}s that
actually occur in~$!A$.  This is the content of the next theorem.  We
require !!{variable} assignments to assign values to all !!{variable}s simply
because it makes things a lot easier.
\end{explain}

\begin{prop}\ollabel{prop:satindep}
If $x_1$, \dots, $x_n$ are the only free !!{variable}s in $!A$ and $s(x_i)
= s'(x_i)$ for $i = 1$, \dots, $n$, then $\Sat{M}{!A}[s]$ iff
$\Sat{M}{!A}[s']$.
\end{prop}

\begin{proof}
We use induction on the complexity of $!A$. For the base case, where
$!A$ is atomic, $!A$ can be: 
\iftag{prvTrue}{$\ltrue$,}{} 
\iftag{prvFalse}{$\lfalse$,}{} 
$R(t_1 \ldots t_k)$ for a $k$-place predicate $R$ and terms
$t_1,\ldots,t_k$, or $\eq[t_1][t_2]$ for terms $t_1$ and $t_2$.

\begin{enumerate}
\tagitem{prvTrue}{%
  \indcase{!A}{\ltrue}{both $\Sat{M}{\indfrm}[s]$ and
    $\Sat{M}{\indfrm}[s']$.}}{}

\tagitem{prvFalse}{%
  \indcase{!A}{\lfalse}{both $\Sat/{M}{!A}[s]$ and
    $\Sat/{M}{!A}[s']$.}}{}

\item
  \indcase{!A}{\Atom{R}{t_1, \ldots, t_k}}{let $\Sat{M}{\indfrm}[s]$. Then
    $\langle \Value{t_1}{M}[s], \ldots, \Value{t_k}{M}[s] \rangle \in
    \Assign{R}{M}$. For $1 \eq i \eq k$, if $t_i$ is a constant, then
    $\Value{t_i}{M}[s] = \Value{t_i}{M} = \Value{t_i}{M}[s']$. If
    $t_i$ is a free !!{variable}, then since the mappings $s$ and $s'$
    agree on all free !!{variable}s, $\Value{t_i}{M}[s] = s(t_i) =
    s'(t_i) = \Value{t_i}{M}[s']$. Similarly, if $t_i$ is of the form
    $f(t'_1,\ldots,t'_j)$, we will also get $\Value{t_i}{M}[s] =
    \Value{t_i}{M}[s']$. Hence, $\Value{t_i}{M}[s] =
    \Value{t_i}{M}[s']$ for any term $t_i$ for $i = 1$, \dots,~$k$, so
    we also have $\langle \Value{t_i}{M}[s'], \ldots,
    \Value{t_k}{M}[s'] \rangle \in \Assign{R}{M}$.}
\item
  \indcase{!A}{\eq[t_1][t_2]}{if $\Sat{M}{\indfrm}[s]$,
    $\Value{t_1}{M}[s'] = \Value{t_1}{M}[s] = \Value{t_2}{M}[s] =
    \Value{t_2}{M}[s']$, so $\Sat{M}{\eq[t_1][t_2]}[s']$.}
\end{enumerate}

Now assume $\Sat{M}{!B}[s]$ iff $\Sat{M}{!B}[s']$ for all !!{formula}s
$!B$ less complex than $!A$. The induction step proceeds by cases
determined by the main operator of $!A$. In each case, we only
demonstrate the forward direction of the !!{biconditional}; the proof
of the reverse direction is symmetrical.

\begin{enumerate}
\tagitem{defNot}{}{%
  \iftag{probNot}{%
    \indcase!{!A}{\lnot !B}{}}{%
    \indcase{!A}{\lnot !B}{if $\Sat{M}{\indfrm}[s]$, then
      $\Sat/{M}{!B}[s]$, so by the induction hypothesis,
      $\Sat/{M}{!B}[s']$, hence $\Sat{M}{\indfrm}[s']$.}}}

\tagitem{defAnd}{}{%
  \iftag{probAnd}{%
    \indcase!{!A}{!B \land !C}{}}{%
    \indcase{!A}{!B \land !C}{if $\Sat{M}{\indfrm}[s]$, then
      $\Sat{M}{!B}[s]$ and $\Sat{M}{!C}[s]$, so by induction
      hypothesis, $\Sat{M}{!B}[s']$ and $\Sat{M}{!C}[s']$. Hence,
      $\Sat{M}{\indfrm}[s']$.}}}

\tagitem{defOr}{}{%
  \iftag{probOr}{%
    \indcase!{!A}{!B \lor !C}{}}{%
    \indcase{!A}{!B \lor !C}{if $\Sat{M}{\indfrm}[s]$, then
      $\Sat{M}{!B}[s]$ or $\Sat{M}{!C}[s]$. By induction hypothesis,
      $\Sat{M}{!B}[s']$ or $\Sat{M}{!C}[s']$, so $\Sat{M}{\indfrm}[s']$.}}}

\tagitem{defIf}{}{%
  \iftag{probIf}{%
    \indcase!{!A}{!B \lif !C}{}}{%
    \indcase{!A}{!B \lif !C}{if $\Sat{M}{\indfrm}[s]$, then
    $\Sat/{M}{!B}[s]$ or $\Sat{M}{!C}[s]$. By the induction hypothesis,
    $\Sat/{M}{!B}[s']$ or $\Sat{M}{!C}[s']$, so $\Sat{M}{\indfrm}[s']$.}}}

\tagitem{defIff}{}{%
  \iftag{probIff}{%
    \indcase!{!A}{!B \liff !C}{}}{%
    \indcase{!A}{!B \liff !C}{if $\Sat{M}{\indfrm}[s]$, then either
      $\Sat{M}{!B}[s]$ and $\Sat{M}{!C}[s]$, or $\Sat/{M}{!B}[s]$ and
      $\Sat/{M}{!C}[s]$. By the induction hypothesis, either
      $\Sat{M}{!B}[s']$ and $\Sat{M}{!C}[s']$ or $\Sat/{M}{!B}[s']$
      and $\Sat/{M}{!C}[s']$. In either case, $\Sat{M}{\indfrm}[s']$.}}}

\tagitem{defEx}{}{%
  \iftag{probEx}{%
    \indcase!{!A}{\lexists[x][!B]}{}}{%
    \indcase{!A}{\lexists[x][!B]}{if $\Sat{M}{\indfrm}[s]$, there is an
      $x$-variant $\bar{s}$ of $s$ so that $\Sat{M}{!B}[\bar{s}]$. Let
      $\bar{s}'$ denote the $x$-variant of $s'$ that assigns the same
      thing to $x$ as does $\bar{s}$: then by the induction
      hypothesis, $\Sat{M}{!B}[\bar{s}']$. Hence, there is an
      $x$-variant of $s'$ that satisfies $!B$, so
      $\Sat{M}{\indfrm}[s']$.}}}

\tagitem{defAll}{}{%
  \iftag{probAll}{%
    \indcase!{!A}{\lforall[x][!B]}{}}{%
    \indcase{!A}{\lforall[x][!B]}{if $\Sat{M}{\indfrm}[s]$, then for
      every $x$-variant $\bar{s}$ of $s$,
      $\Sat{M}{!B}[\bar{s}]$. Hence, if $\bar{s}'$ is the $x$-variant
      of $s'$ that assigns the same thing to $x$ as does $\bar{s}$,
      then we have $\Sat{M}{!B}[\bar{s}']$. Hence, every $x$-variant
      of $s'$ satisfies $!B$, so $\Sat{M}{\indfrm}[s']$}}}
\end{enumerate}
By induction, we get that $\Sat{M}{!A}[s]$ iff $\Sat{M}{!A}[s']$
whenever $x_1$, \dots, $x_n$ are the only free !!{variable}s in $!A$ and
$s(x_i)=s'(x_i)$ for $i=1$, \dots,~$n$.
\end{proof}
 
\begin{probtag}{probNot,probOr,probAnd,probIf,probEx,probAll}
Complete the proof of \olref[fol][syn][sat]{prop:satindep}.
\end{probtag}

\begin{defn}
If $!A$ is a sentence, we say that a !!{structure}~$\Struct M$
\emph{satisfies}~$!A$, $\Sat{M}{!A}$, iff $\Sat{M}{!A}[s]$ for all
!!{variable} assignments~$s$.
\end{defn}

\begin{prob}
Show that if $!A$ is a sentence, $\Sat{M}{!A}$ iff \emph{there is} a
!!{variable} assignment~$s$ so that $\Sat{M}{!A}[s]$.
\end{prob}

\end{document}
