% % The Default OLP Configuration File `open-logic-config.sty`
% % OpenLogic Project
%
% Description
% ===========
%
% This file contains all commands and environments that are meant to
% be configured, changed, or adapted by a user generating their own
% text based on OLP text.  **Do not edit this file to customize your
% OLP-derived text!** A file `myversion.tex` adapted from
% `open-logic-complete.tex` (or from any of the contributed example
% master files) will include `myversion-config.sty` if it exists, and
% otherwise will include this file. So if you'd like to make changes,
% instead **copy this file to `myversion-config.sty` and edit for
% customization**.

\NeedsTeXFormat{LaTeX2e}

% Symbols
% =======

% Formula metavariabes 
% --------------------
%
% Use the exclamation point symbol `!` immediately in front of an
% uppercase letter in math mode for formula metavariables.  By
% default, `!A`, `!B`, ... are typeset as $\varphi$, $\psi$, $\chi$,
% ... if you use the command `\olgreekformulas`. If this is not desired,
% and you'd like $A$, $B$, $C$, ... instead, comment out this line.

\olgreekformulas

% Logical symbols
% ---------------

% The following commands are used in the OLP texts for logical
% symbols. Their definitions can be customized to produce different
% output.

% ### Truth Values
%
% - `\True` defaults to $1$ and `\False` to $0$.

\newcommand*{\True}{1}
\newcommand*{\False}{0}

% ### Propositional Constants and Connectives
%
% - Falsity is `\lfalse` and defaults to $\bot$.

\newcommand*{\lfalse}{\bot}

% - Truth is `\ltrue` and defaults to $\top$.

\newcommand*{\ltrue}{\top}

% - Negation is `\lnot` and defaults to $\lnot$.  To use a different
% symbol (e.g., tilde), uncomment/change the following line.

% \renewcommand*{\lnot}{\mathord{\sim}}

% - Conjunction is `\land` and deaults to $\land$.  to use ampersand,
% uncomment the following line

% \renewcommand*{\land}{\mathbin{\&}}

% - Disjunction `\lor` and defaults to $\lor$.

% - Conditional is `\lif` and defaults to $\rightarrow$.  To use a
% different symbol, replace `\rightarrow` in the definition, e.g., by
% `\supset`

\newcommand*{\lif}{\rightarrow}

% - The biconditional is `\liff` anddefaults to $\leftrightarrow$.  To
% use the triple bar $\equiv$ replace with `\equiv`.

\newcommand*{\liff}{\leftrightarrow}

% Quantifiers 
% ----------- 

% The quantifier symbols are provided as commands `\lexists` and
% `\lforall` which take two optional arguments. If no arguments are
% provided, it they just typeset the quantifier symbol. With one
% optional argument they produce the quantifier together with a
% variable, and this may include parenthesesaround the quantifier and
% variable. The second optional argument producesthe
% quantifier/variable combination plus the formula in the scope of the
% formula with appropriate spacing.  For instance,
% `\lexists[x][!A(x)]` will, bydefault, produce $\exists
% x\,\varphi(x)$.

% - The existential quantifier is `\lexists`.  Replace `\exists` with
% `\boldsymbol{\exists}` for boldface, or redefine appropriately if
% you want parentheses around $\exists x$.

\DeclareDocumentCommand \lexists { o o } {
    \IfNoValueTF {#1} 
        { \exists }    % no arguments
        { \exists #1 } % one argument: variable
    \IfNoValueTF {#2} 
        \relax
        { \, #2 }      % two arguments: space and matrix
}

% - The universal quantifier is `\lforall`.

\DeclareDocumentCommand \lforall { o o } {
    \IfNoValueTF {#1} 
        { \forall }    % no arguments
        { \forall #1 } % one argument: variable
    \IfNoValueTF {#2} 
        \relax
        { \, #2 }      % two arguments: space and matrix
}

% - The identity relation is also provided as `\eq`. By itself, it
% produces the identity reation symbol (default: $=$) by itself. With
% two optional arguments, it typesets the corresponding atomic
% formula, e.g., `\eq[x][y]` produces $x = y$.  `\eq/` produces the
% negated symbol (formula).

\DeclareDocumentCommand \eq { t{/} o o } {
  \IfNoValueTF {#3}
    % no optional arguments: just typeset symbol
    { \IfBooleanTF{#1}{ \neq }{ = } }
    % optional arguments: typeset atomic formula
    { \IfBooleanTF{#1}{ #2 \neq #3}{#2 = #3} }
}

% - The sequent symbol `\Sequent` produces $\Rightarrow$ by
% default. Change the definition for $\vdash$, or another symbol.

\newcommand*{\Sequent}{\Rightarrow}

% The sequent symbol in proofs displays as the above sequent symbol

\let\fCenter\Sequent


% Metalogical Relations
% ---------------------
%
% Metalogical relationships, such as truth in a structure, validity,
% consequence, and provability, are also provided as commands. Uniform
% use of these commandsinstead of hard-coded typesetting according to
% specific conventions guarantees that by changing the definitions
% below you can uniformly change notation in the text.


% ### The satisfaction/truth relation
%
% The relation of being satisfied in a structure (relative to an
% assignment) isprovided as the command `\Sat` with two mandatory
% arguents (the structure and the formula) and one optional argument
% (the assignment).  Use `\Sat/` to create the negated relation.  By
% default, `\Sat{M}{!A}[s]` istypeset as $\mathfrak{M}, s\models
% \varphi$.

\DeclareDocumentCommand \Sat { t{/} m m o } {
  \IfBooleanTF{#1}{
    % negated
    \IfNoValueTF {#4} 
        { \Struct #2 \not\models #3 }
        { \Struct #2, #4 \not\models #3}}{
    % not negated
    \IfNoValueTF {#4} 
        { \Struct #2 \models #3 }
        { \Struct #2, #4 \models #3 }}
}


% ### The derivability relation

% `\Proves` is used to create the symbol for the derivability
% relation, `\Proves/` for the negation. By default this creates
% $\vdash$. The optional argument is used for the calculusor logic
% relative to which the provability relation is defined; by default it
% creates a subscript on the turnstile.

\DeclareDocumentCommand \Proves { t{/} o } {
  \IfBooleanTF {#1}{
    \IfNoValueTF {#2} 
        { \not\vdash }
        { \not\vdash_{#2} }}{
    \IfNoValueTF {#2} 
        { \vdash }
        { \vdash_{#2} }}
}

% ### The semantic consequence relation relation

% `\Entails` is the semantic counterpart of `\Proves`. 

\DeclareDocumentCommand \Entails { o } {
    \IfNoValueTF {#1} 
        { \models }
        { \models_{#1} }
}

% ### Model-theoretic notions and symbols

% - `\Domain` - domain of a structure, e.g., `\Domain M` gives
% $\left|\mathfrak M\right|$.

\newcommand*{\Domain}[1]{\left| \Struct #1 \right|}

% - `\Assign` - Assignment (value of) of a constant/predicate symbol
% in a structure; e.g., `\Assign R M` produces $R^\mathfrak{M}$.

\newcommand*{\Assign}[2]{#1^{\Struct #2}}

% - `\Value` - Value of a term in a structure. Takes two mandatory
% arguments (term and structure) and one optional argument (variable
% assignment). By default, `\Value{t}{M}[s]` produces 
% $\mathrm{Val}^\mathfrak{M}_s(t)$.

\DeclareDocumentCommand \Value { m m o} {
    \IfNoValueTF {#3}
        % optional argument not present
        { \mathrm{Val}^{\Struct #2}(#1) }
        % optional argument present
        { \mathrm{Val}^{\Struct #2}_{#3}(#1) }
}

% - `\substruct`: symbol for the substructure relation

\newcommand*{\substruct}{\subseteq}

% - `\ident`: syntactic identity between expressions (infix realtion)
\newcommand*{\ident}{\equiv}



% Special Sets and Mathematical Symbols
% -------------------------------------

% ### Set-theoretic operators

% - Set abstracts: Use `\Setabs{x}{!A(x)}` to produce the set abstract
% $\{ x : \varphi(x) \}$. If you prefer a $\mid$ to :, change the
% definition accordingly.

\newcommand*{\Setabs}[2]{\{ #1 : #2 \}}

% - Power set: `\Pow{X}` produces $\wp(X)$

\newcommand{\Pow}[1]{\wp(#1)}

% - `\dom{f}`: domain of a function (mandatory argument)
\newcommand*{\dom}[1]{\mathrm{dom}(#1)}

% - `\ran{f}`: range of a function (mandatory argument)
\newcommand*{\ran}[1]{\mathrm{ran}(#1)}

% - `\len(s)`: length of asequence (mandatory argument)
\newcommand*{\len}[1]{\mathrm{len}(#1)}

% - `\restrict`: restriction of a function to a set (infix operator)
\newcommand*{\restrict}{\upharpoonright}


% ### Particular sets

% - Natural numbers: `\Nat`
\def\Nat{\mathbb{N}}

% - Integers: `\Int`
\def\Int{\mathbb{Z}}

% - Real numbers: `\Real`
\def\Real{\mathbb{R}}

% - Rational numbers: `\Rat`
\def\Rat{\mathbb{Q}}

% - Binary strings: `\BinStr`
\def\BinStr{\mathbb{B}}

% ### Symbols for Turing Machines

% - `\TMendtape` - symbol indicating left end of tape
\newcommand*{\TMendtape}{\triangleright}

% - `\TMblank` - symbol for a blank
\newcommand*{\TMblank}{\mathord{\text{\textvisiblespace}}}

% - `\TMstroke` - single stroke symbol on tape
\newcommand*{\TMstroke}{\mid}


% Typesetting commands for logical concepts
% =========================================

% In order to unformly typeset certain types of symbols uniformly, the
% OLP texts use special commands which carry out the
% typesetting. Thus, e.g., all structures, which appear in the texts,
% say, as `\Struct{M}`, can be typeset according to preference. By
% default, they are typeset in fraktur (e.g., $\mathfrak M $) but this
% can be configured by changing the definition of the `\Struct`
% command.  Note that often the default behavior is to only apply the
% typeface command to the first token in the argument, e.g., `\Struct
% M_n` will generate $\mathfrak M_n$ and not $\mathfrak{M_n}$.

% - `\Struct` - First-order structures; by default, the first token in Fraktur
\newcommand*{\Struct}[1]{\mathfrak #1}

% - `\Mod` - modal structures; default: set first token in Fraktur
\newcommand*{\Mod}[1]{\mathfrak #1}

% - `\Lang` - Languages; default: set first token in callgraphic font
\newcommand*{\Lang}[1]{\mathcal #1}

% - `\Log` - Logics; default: set entirely in boldface
\newcommand*{\Log}[1]{\mathbf{#1}}

% - `\Obj` - Object-language symbols; default: set entirely in
% sans-serif italics
\newcommand*{\Obj}[1]{\mathsfit{#1}}

%  - `\Atom` - Atomic formula; default produces predicate symbol
%  followed by argumnets surrounded by parentheses. Some prefer no
%  parentheses around the arguments.
\newcommand*{\Atom}[2]{ #1(#2) }



% Sets of Expressions
% ===================
%
% The following commands provide uniform notation for sets of
% expressions, such as the set of formulas of a language. Typically
% the parameter (language) can be providedas an optional argument.  By
% default, if the argument is given, they aretypeset following the
% symbol within parentheses, i.e., the symbols are treated as
% operators (e.g., $\mathrm{Frm}(\mathcal{L})$. Redefine the commands
% to, e.g., typeset the parameters as subscripts (e.g.,
% $\mathrm{Frm}_\mathcal{L}$.

% - `\Var`: the set of propositional variables

\def\Var{\mathrm{Var}}

% - `\Trm[L]`: the set of terms (optional argument: language)

\DeclareDocumentCommand \Trm { o } {
    \IfNoValueTF {#1} 
        { \mathrm{Trm} }
        { \mathrm{Trm}({\Lang #1}) }
}

% - `\Frm[L]`: the set of formulas (optional argument: language)
\DeclareDocumentCommand \Frm { o } {
    \IfNoValueTF {#1} 
        { \mathrm{Frm} }
        { \mathrm{Frm}({\Lang #1}) }
}

% - `\SubFrm[!A]`: the set of subformulas of a formula (mandatory
% argument: formula)

\DeclareDocumentCommand \SubFrm { m } {
        \mathrm{SFrm}({#1})
}

% - `\Sent[L]`: theset of sentences (optional argument: language)
\DeclareDocumentCommand \Sent { o } {
    \IfNoValueTF {#1} 
        { \mathrm{Sent} }
        { \mathrm{Sent}({\Lang #1}) }
}


% Environments
% ============

% Theorem-like Environments
% -------------------------

% Theorem-like environments are provided for theorem (`thm`),
% definition (`defn`), lemma (`lem`), proposition (`prop`), corollary
% (`cor`), example (`ex`), problem (`prob`), remark (`rem`), and
% convention (`conv`). The definitions make use of the `thmtools`
% package.  To change the numbering or style of these enviornments,
% adjust their definitions. Refer to the [`thmtools`
% documentation](http://www.ctan.org/pkg/thmtools).

\declaretheorem[
  style=plain,
  name=Theorem,
  numberwithin=chapter]{thm}

\declaretheorem[
  style=definition,
  name=Example,
  sibling=thm]{ex}

\declaretheorem[
  style=plain,
  name=Lemma,
  refname={lemma,lemmata},
  sibling=thm]{lem}

\declaretheorem[
  style=plain,
  name=Proposition,
  sibling=thm]{prop}

\declaretheorem[
  style=plain,
  name=Corollary,
  sibling=thm]{cor}

\declaretheorem[
  style=definition,
  name=Definition,
  sibling=thm]{defn}

\declaretheorem[
  style=definition,
  name=Problem,
  numberwithin=chapter]{prob}

\declaretheorem[
  style=remark,
  name=Remark]{rem}

\declaretheorem[
  style=remark,
  name=Note]{note}

\declaretheorem[
  style=remark,
  name=Case]{case}

\declaretheorem[
  style=remark,
  name=Convention]{conv}


% Other Enviroments
% -----------------

% OLP texts make use of a number of environments to encapsulate types
% of discursive text.  By default, these environments simply print
% their content without any special treatment. If you want to typeset
% any of them differntly, you can change the definition of the
% environment here. E.g., you might want digressions in asmaller font
% and indented.  Refer to the \LaTeX\ documentation for how to
% accomplish this.

% OLP will provide two custom mechanisms for treating environments:
% supressing and deferring. Environments can be supressed by
% redefining them as the `comment` environment. For instance, to not
% print any digressions at all, add the lines
% ```
% \let\digress\comment
% \let\enddigress\endcomment
% ```
% after the definition of `digress`.

% - `wordy`: Any long and informal explanation that's not necessary 

\newenvironment{wordy}{}{}

% - `intro`: for comments and comparisions to other introductory
% texts, e.g., regarding terminology, conventions, or proof methods.

\newenvironment{intro}{}{}

% - `pedantic`: for pedantic comments which users may want to exclude.

\newenvironment{pedantic}{}{}

% - `digress`: for digressions

\newenvironment{digress}{}{}


% Tokens
% ======

% The following terms are *tokenized* throughout OLP. This means that
% by changing the definition in the configuration file, the term as
% printed will also change. This is simpler than searching and
% replacing these terms in all OLP texts, and it will also treat
% plurals as well as occurrences of the term at the beginning of a
% sentence (where it should be capitalized) correctly.

% Tokens are defined using the `\settexttoken` command.
% ```
% \settexttoken{token}{singular}{plural}[Singular][Plural]
% ```
% Here `token` is the term as it is used in the source text, where it
% typically is used as `!!{token}`.  `singular` and `plural` are the
% text you want printed wherever an OLP text contains `!!{token}` or
% `!p{token}`.  In sentence-initial position, OLP texts would use
% `!S{token}` and `!P{token}` to create capitalized versions of these
% token replacements.  By default, they are generated from `singluar`
% and `plural` by capitalizing the first chracter, but can be provided
% explicitly to `\settexttoken` as optional arguments.

% - `formulas`: defaults to "formula/formulae", redefine for
% "formulas," or "wff".

\settexttoken{formula}{formula}{formul{\ae}}

% - `variable`: defaults to "variable/varaibles", redefine to be more
% specific, e.g., "individual variable", "object veriable".

\settexttoken{variable}{variable}{variables}

% - `constant`: defaults to "constant", redefine for "individual
% constant'', "constant symbol."

\settexttoken{constant}{constant symbol}{constant symbols}

% - `predicate`: defaults to "predicate symbol".
\settexttoken{predicate}{predicate symbol}{predicate symbols}

% - `function`: defaults to "function symbol".
\settexttoken{function}{function symbol}{function symbols}

% - `identity`: defaults to "identity predicate", redefine for
% "equality predicate."

\settexttoken{identity}{identity predicate}{identity predicates}

% - `conditional`: defaults to "conditional", redefine for "implication."

\settexttoken{conditional}{conditional}{conditionals}

% - `biconditional`: defaults to "biconditional", redefine for "equivalence."

\settexttoken{biconditional}{biconditional}{biconditionals}

% - `falsity`: the falsity symbol, defaults to "falsity", redefine for
% "absurdity."

\settexttoken{falsity}{falsity}{falsities}

% - `structure`: term for first-order structures, defaults to
% "structure", redefine for "interpretation", "model".

\settexttoken{structure}{structure}{structures}

% - `enumerable`: term for finite or countably infinite; defaults to
% "enumerable", redefine for "countable".

\settexttoken{enumerable}{enumerable}{enumerable}

% - `denumerable`: term for countably infinite; defaults to "denumerable". 

\settexttoken{denumerable}{denumerable}{denumerable}
