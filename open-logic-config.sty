% % The Default OLP Configuration File `open-logic-config.sty`
% % OpenLogic Project
%
% Description
% ===========
%
% This file contains all commands and environments that are meant to
% be configured, changed, or adapted by a user generating their own
% text based on OLP text.  **Do not edit this file to customize your
% OLP-derived text!** A file `myversion.tex` adapted from
% `open-logic-complete.tex` (or from any of the contributed example
% master files) will include `myversion-config.sty` if it exists. It
% will do so after it loads this file, so your `myversion-config.sty`
% will redefine the defaults.  This means you won't have to include
% everythng, e.g., you can just change some tags and nothing else. You
% may copy and paste edfinitions you want to change into that file, or
% copy thi file, rename it `myversion-config.sty` and delete anything
% you'd like to leave as the default.

\NeedsTeXFormat{LaTeX2e}

% Symbols
% =======

% Formula metavariabes 
% --------------------
%
% Use the exclamation point symbol `!` immediately in front of an
% uppercase letter in math mode for formula metavariables.  By
% default, `!A`, `!B`, ... are typeset as $\varphi$, $\psi$, $\chi$,
% ... if you use the command `\olgreekformulas`. If this is not desired,
% and you'd like $A$, $B$, $C$, ... instead, use `\ollatinformulas`.

\olgreekformulas

% Logical symbols
% ---------------

% The following commands are used in the OLP texts for logical
% symbols. Their definitions can be customized to produce different
% output.

% ### Truth Values
%
% - `\True` defaults to $1$ and `\False` to $0$.

\DeclareDocumentMacro \True {1}
\DeclareDocumentMacro \False {0}

% ### Propositional Constants and Connectives
%
% - Falsity is `\lfalse` and defaults to $\bot$.

\DeclareDocumentMacro \lfalse {\bot}

% - Truth is `\ltrue` and defaults to $\top$.

\DeclareDocumentMacro \ltrue {\top}

% - Negation is `\lnot` and defaults to $\lnot$.  To use a different
% symbol (e.g., tilde), use the following line.

% `\DeclareDocumentMacro \lnot {\mathord{\sim}}`

% - Conjunction is `\land` and deaults to $\land$.  to use ampersand,
% uncomment the following line

% `\DeclareDocumentMacro \land {\mathbin{\&}}`

% - Disjunction `\lor` and defaults to $\lor$.

% - Conditional is `\lif` and defaults to $\rightarrow$.  To use a
% different symbol, replace `\rightarrow` in the definition, e.g., by
% `\supset`

\DeclareDocumentMacro \lif {\rightarrow}

% - The biconditional is `\liff` and defaults to $\leftrightarrow$.  To
% use the triple bar $\equiv$ replace with `\equiv`.

\DeclareDocumentMacro \liff {\leftrightarrow}

% Quantifiers 
% ----------- 

% The quantifier symbols are provided as commands `\lexists` and
% `\lforall` which take two optional arguments. If no arguments are
% provided, it they just typeset the quantifier symbol. With one
% optional argument they produce the quantifier together with a
% variable, and this may include parenthesesaround the quantifier and
% variable. The second optional argument producesthe
% quantifier/variable combination plus the formula in the scope of the
% formula with appropriate spacing.  For instance,
% `\lexists[x][!A(x)]` will, bydefault, produce $\exists
% x\,\varphi(x)$.

% - The existential quantifier is `\lexists`.  Replace `\exists` with
% `\boldsymbol{\exists}` for boldface, or redefine appropriately if
% you want parentheses around $\exists x$.

\DeclareDocumentCommand \lexists { o o } {
    \IfNoValueTF {#1} 
        { \exists }    % no arguments
        { \exists #1 } % one argument: variable
    \IfNoValueTF {#2} 
        \relax
        { \, #2 }      % two arguments: space and matrix
}

% - The universal quantifier is `\lforall`.

\DeclareDocumentCommand \lforall { o o } {
    \IfNoValueTF {#1} 
        { \forall }    % no arguments
        { \forall #1 } % one argument: variable
    \IfNoValueTF {#2} 
        \relax
        { \, #2 }      % two arguments: space and matrix
}

% - The identity relation is also provided as `\eq`. By itself, it
% produces the identity reation symbol (default: $=$) by itself. With
% two optional arguments, it typesets the corresponding atomic
% formula, e.g., `\eq[x][y]` produces $x = y$.  `\eq/` produces the
% negated symbol (formula).

\DeclareDocumentCommand \eq { t{/} o o } {
  \IfNoValueTF {#3}
    % no optional arguments: just typeset symbol
    { \IfBooleanTF{#1}{ \neq }{ = } }
    % optional arguments: typeset atomic formula
    { \IfBooleanTF{#1}{ #2 \neq #3}{#2 = #3} }
}

% - The sequent symbol `\Sequent` produces $\Rightarrow$ by
% default. Change the definition for $\vdash$, or another symbol.

\DeclareDocumentMacro \Sequent {\Rightarrow}

% The sequent symbol in proofs displays as the above sequent symbol

\DeclareDocumentMacro \fCenter {\ensuremath{\,\Sequent\,}}


% Metalogical Relations
% ---------------------
%
% Metalogical relationships, such as truth in a structure, validity,
% consequence, and provability, are also provided as commands. Uniform
% use of these commandsinstead of hard-coded typesetting according to
% specific conventions guarantees that by changing the definitions
% below you can uniformly change notation in the text.


% ### Substiution

% The operation of substituting a term for a (free) variable in
% another term or in a formula.  \#1 is the formula, \#2 is the term,
% \#3 is the variable.  Common notations are $\varphi^t_x$,
% $\varphi(t/x)$, $\varphi[x/t]$, or $S^t_x \varphi$.

\DeclareDocumentCommand \Subst { m m m } {
  #1[#2/#3]}



% ### The satisfaction/truth relation
%
% The relation of being satisfied in a structure (relative to an
% assignment) isprovided as the command `\Sat` with two mandatory
% arguents (the structure and the formula) and one optional argument
% (the assignment).  Use `\Sat/` to create the negated relation.  By
% default, `\Sat{M}{!A}[s]` is typeset as $\mathfrak{M}, s \models
% \varphi$.

\DeclareDocumentCommand \Sat { t{/} m m o } {
  \IfBooleanTF{#1}{
    % negated
    \IfNoValueTF {#4} 
        { \Struct #2 \not\models #3 }
        { \Struct #2, #4 \not\models #3}}{
    % not negated
    \IfNoValueTF {#4} 
        { \Struct #2 \models #3 }
        { \Struct #2, #4 \models #3 }}
}


% ### The derivability relation

% `\Proves` is used to create the symbol for the derivability
% relation, `\Proves/` for the negation. By default this creates
% $\vdash$. The optional argument is used for the calculusor logic
% relative to which the provability relation is defined; by default it
% creates a subscript on the turnstile.

\DeclareDocumentCommand \Proves { t{/} o } {
  \IfBooleanTF {#1}{
    \IfNoValueTF {#2} 
        { \not\vdash }
        { \not\vdash_{#2} }}{
    \IfNoValueTF {#2} 
        { \vdash }
        { \vdash_{#2} }}
}

% ### The semantic consequence relation relation

% `\Entails` is the semantic counterpart of `\Proves`. 

\DeclareDocumentCommand \Entails { t{/} o } {
  \IfBooleanTF {#1}{
    \IfNoValueTF {#2} 
        { \not\models }
        { \not\models_{#2} }}{
    \IfNoValueTF {#2} 
        { \models }
        { \models_{#2} }}
}


% ### Model-theoretic notions and symbols

% - `\Domain` - domain of a structure, e.g., `\Domain M` gives
% $\left|\mathfrak M\right|$.

\DeclareDocumentCommand \Domain { m }{\left| \Struct #1 \right|}

% - `\Assign` - Assignment (value of) of a constant/predicate symbol
% in a structure; e.g., `\Assign R M` produces $R^\mathfrak{M}$.

\DeclareDocumentCommand \Assign { m m }{#1^{\Struct #2}}

% - `\Value` - Value of a term in a structure. Takes two mandatory
% arguments (term and structure) and one optional argument (variable
% assignment). By default, `\Value{t}{M}[s]` produces 
% $\mathrm{Val}^\mathfrak{M}_s(t)$.

\DeclareDocumentCommand \Value { m m o} {
    \IfNoValueTF {#3}
        % optional argument not present
        { \mathrm{Val}^{\Struct #2}(#1) }
        % optional argument present
        { \mathrm{Val}^{\Struct #2}_{#3}(#1) }
}

% - `\substruct`: symbol for the substructure relation

\DeclareDocumentMacro \substruct {\subseteq}

% - `\Theory`: theory of a structure

\DeclareDocumentCommand \Theory { m } {\mathrm{Th}(\Struct{#1})}

% - `\elemequiv`: elementary equivalence (infix realtion)

\DeclareDocumentCommand \elemequiv { t{/} o } {
  \IfBooleanTF {#1}{
    \IfNoValueTF {#2} 
        { \not\equiv }
        { \not\equiv_{#2} }}{
    \IfNoValueTF {#2} 
        { \equiv }
        { \equiv_{#2} }}
}

% `\iso`: relation of (partial) isomorphism

\DeclareDocumentCommand \iso { t{/} o } {
  \IfBooleanTF {#1}{
    \IfNoValueTF {#2} 
        { \not\simeq }
        { \not\simeq_{#2} }}{
    \IfNoValueTF {#2} 
        { \simeq }
        { \simeq_{#2} }}
}



% - `\ident`: syntactic identity between expressions (infix realtion)

\DeclareDocumentMacro \ident {\equiv}

% `\QuantRank`: quantifier rank of a formula

\DeclareDocumentCommand \QuantRank { m } {\mathrm{qr}(#1)}


% Recursion-theoretic Notions and Symbols
% ---------------------------------------

% `\Proj`: projection functions

\DeclareDocumentCommand \Proj { m m } {P^{#1}_{#2}}

% `\tsub`: truncated subtraction function

% `\Char`: characteristic function

\DeclareDocumentCommand \Char { m } {\chi_{#1}}

\DeclareDocumentMacro \tsub {\mathbin{\dot-}}

% `\defis`: definitional identity

\DeclareDocumentMacro \defis {=} %{\mathrel{=_\mathrm{df}}}

% `\defiff`: definitional equivalence

\DeclareDocumentMacro \defiff {\Leftrightarrow}

% `\concat`: concatenation of sequences

\DeclareDocumentMacro \concat {\frown}

% Special Sets and Mathematical Symbols
% -------------------------------------

% ### Set-theoretic operators

% - Set abstracts: Use `\Setabs{x}{!A(x)}` to produce the set abstract
% $\{ x : \varphi(x) \}$. If you prefer a $\mid$ to :, change the
% definition accordingly.

\DeclareDocumentCommand \Setabs { m m }{\{ #1 : #2 \}}

% - Power set: `\Pow{X}` produces $\wp(X)$

\DeclareDocumentCommand \Pow { m }{\wp(#1)}

% - `\dom{f}`: domain of a function (mandatory argument)

\DeclareDocumentCommand \dom { m }{\mathrm{dom}(#1)}

% - `\ran{f}`: range of a function (mandatory argument)
\DeclareDocumentCommand \ran { m }{\mathrm{ran}(#1)}

% - `\len(s)`: length of asequence (mandatory argument)
\DeclareDocumentCommand \len { m }{\mathrm{len}(#1)}

% - `\restrict`: restriction of a function to a set (infix operator)
\DeclareDocumentMacro \restrict {\upharpoonright}


% ### Particular sets

% - Natural numbers: `\Nat`
\DeclareDocumentMacro \Nat {\mathbb{N}}

% - Integers: `\Int`
\DeclareDocumentMacro \Int {\mathbb{Z}}

% - Real numbers: `\Real`
\DeclareDocumentMacro \Real {\mathbb{R}}

% - Rational numbers: `\Rat`
\DeclareDocumentMacro \Rat {\mathbb{Q}}

% - Binary strings: `\BinStr`
\DeclareDocumentMacro \BinStr {\mathbb{B}}

% ### Symbols for Turing Machines

% - `\TMendtape` - symbol indicating left end of tape
\DeclareDocumentMacro \TMendtape {\triangleright}

% - `\TMblank` - symbol for a blank
\DeclareDocumentMacro \TMblank {\mathord{\text{\textvisiblespace}}}

% - `\TMstroke` - single stroke symbol on tape
\DeclareDocumentMacro \TMstroke {\mid}


% Typesetting commands for logical concepts
% =========================================

% In order to unformly typeset certain types of symbols uniformly, the
% OLP texts use special commands which carry out the
% typesetting. Thus, e.g., all structures, which appear in the texts,
% say, as `\Struct{M}`, can be typeset according to preference. By
% default, they are typeset in fraktur (e.g., $\mathfrak M $) but this
% can be configured by changing the definition of the `\Struct`
% command.  Note that often the default behavior is to only apply the
% typeface command to the first token in the argument, e.g., `\Struct
% M_n` will generate $\mathfrak M_n$ and not $\mathfrak{M_n}$.

% - `\Struct` - First-order structures; by default, the first token in Fraktur
\DeclareDocumentCommand \Struct { m }{\mathfrak #1}

% - `\Mod` - modal structures; default: set first token in Fraktur
\DeclareDocumentCommand \Mod { m }{\mathfrak #1}

% - `\Lang` - Languages; default: set first token in callgraphic font
\DeclareDocumentCommand \Lang { m }{\mathcal #1}

% - `\Log` - Logics; default: set entirely in boldface
\DeclareDocumentCommand \Log { m }{\mathbf{#1}}

% - `\Obj` - Object-language symbols; default: set entirely in
% sans-serif italics
\DeclareDocumentCommand \Obj { m }{\mathsfit{#1}}

%  - `\Atom` - Atomic formula; default produces predicate symbol
%  followed by argumnets surrounded by parentheses. Some prefer no
%  parentheses around the arguments.
\DeclareDocumentCommand \Atom { m m }{ #1(#2) }

% - `\PIso` - Set of all partial isomorphisms
\DeclareDocumentCommand \PIso { m }{\mathcal{#1}}

% `\fn` -- typeset a function name

\DeclareDocumentCommand \fn { m } {\mathrm{#1}}


% Sets of Expressions
% ===================
%
% The following commands provide uniform notation for sets of
% expressions, such as the set of formulas of a language. Typically
% the parameter (language) can be providedas an optional argument.  By
% default, if the argument is given, they aretypeset following the
% symbol within parentheses, i.e., the symbols are treated as
% operators (e.g., $\mathrm{Frm}(\mathcal{L})$. Redefine the commands
% to, e.g., typeset the parameters as subscripts (e.g.,
% $\mathrm{Frm}_\mathcal{L}$.

% - `\Var`: the set of propositional variables

\def\Var{\mathrm{Var}}

% - `\Trm[L]`: the set of terms (optional argument: language)

\DeclareDocumentCommand \Trm { o } {
    \IfNoValueTF {#1} 
        { \mathrm{Trm} }
        { \mathrm{Trm}({\Lang #1}) }
}

% - `\Frm[L]`: the set of formulas (optional argument: language)
\DeclareDocumentCommand \Frm { o } {
    \IfNoValueTF {#1} 
        { \mathrm{Frm} }
        { \mathrm{Frm}({\Lang #1}) }
}

% - `\SubFrm[!A]`: the set of subformulas of a formula (mandatory
% argument: formula)

\DeclareDocumentCommand \SubFrm { m } {
        \mathrm{SFrm}({#1})
}

% - `\Sent[L]`: theset of sentences (optional argument: language)
\DeclareDocumentCommand \Sent { o } {
    \IfNoValueTF {#1} 
        { \mathrm{Sent} }
        { \mathrm{Sent}({\Lang #1}) }
}

% Commands for uniform formulations
% =================================

% Inductive definitions
% ---------------------

% Inductive definitions typically divide into cases depening on the
% form of a formula for which a concept if defined.  To uniformly
% typeset these definitions flexibly, we provide a command
% `\indcase{formula}{complex formula}{case text}` which (a) typesets a
% uniform description of a case and (b) defines `\indfrm` and
% `\indcomplex` which can then be used in the definitions. For
% instance, in an inductive definition of $\models A$, you might say
% `\indcase{A}{B \land C} $\models \indfrm$ iff $\models B$ and
% $\models C$` to produce: "If $A \equiv B \land C$, then $\models A$
% iff $\models B$ and $\models C$" or, alternatively and more
% succinctly: "$\models B \land C$ iff $\models B$ and $\models C$".
% Use the starred version for the atomic case, and a ! instead of the
% star for a case you to leave as an exercise.

\DeclareDocumentCommand \indcase { s t{!} m m m }{%
  \DeclareDocumentMacro \indfrm {#3}%
  \DeclareDocumentMacro \indfrmp {#3}%
  \DeclareDocumentMacro \indcomplex {#4}%
  \IfBooleanTF{#1}
     {$#3$ is atomic: #5}{}
  \IfBooleanTF{#2}
     {$#3 \ident #4$: exercise.}
     {$#3 \ident #4$: #5}}

% Tokens
% ======

% The following terms are *tokenized* throughout OLP. This means that
% by changing the definition in the configuration file, the term as
% printed will also change. This is simpler than searching and
% replacing these terms in all OLP texts, and it will also treat
% plurals as well as occurrences of the term at the beginning of a
% sentence (where it should be capitalized) correctly.

% Tokens are defined using the `\settexttoken` command.
% ```
% \settexttoken{token}{singular}{plural}[Singular][Plural]
% ```
% Here `token` is the term as it is used in the source text, where it
% typically is used as `!!{token}`.  `singular` and `plural` are the
% text you want printed wherever an OLP text contains `!!{token}` or
% `!p{token}`.  In sentence-initial position, OLP texts would use
% `!S{token}` and `!P{token}` to create capitalized versions of these
% token replacements.  By default, they are generated from `singluar`
% and `plural` by capitalizing the first chracter, but can be provided
% explicitly to `\settexttoken` as optional arguments.

% - `formula`: defaults to "formula/formuls", redefine for
% plural "formulae," or for "wff".

\settexttoken{formula}{formula}{formulas}

% - `subformula`: defaults to "subformula", redefine for plural
% "subformulae," hyphenated spelling "sub-formula", or "sub-wff".

\settexttoken{subformula}{subformula}{subformulas}

% - `variable`: defaults to "variable/variables", redefine to be more
% specific, e.g., "individual variable", "object veriable".

\settexttoken{variable}{variable}{variables}

% - `constant`: defaults to "constant", redefine for "individual
% constant'', "constant symbol."

\settexttoken{constant}{constant symbol}{constant symbols}

% - `predicate`: defaults to "predicate symbol".

\settexttoken{predicate}{predicate symbol}{predicate symbols}

% - `function`: defaults to "function symbol".

\settexttoken{function}{function symbol}{function symbols}

% - `operator`: defaults to "logical operator", redefine for "connective".

\settexttoken{operator}{logical operator}{logical operators}

% - `main operator`: defaults to "main operator", redefine for
% "outermost operator".

\settexttoken{main operator}{main operator}{main operators}

% - `free for`: defaults to "free for", redefine for
% "substitutable for" as in Enderton.

\settexttoken{free for}{free for}{free for}

% - `identity`: defaults to "identity predicate", redefine for
% "equality predicate."

\settexttoken{identity}{identity predicate}{identity predicates}

% - `conditional`: defaults to "conditional", redefine for "implication."

\settexttoken{conditional}{conditional}{conditionals}

% - `biconditional`: defaults to "biconditional", redefine for "equivalence."

\settexttoken{biconditional}{biconditional}{biconditionals}

% - `falsity`: the falsity symbol, defaults to "falsity", redefine for
% "absurdity."

\settexttoken{falsity}{falsity}{falsities}

% - `truth`: the falsity symbol, defaults to "truth", redefine for
% "verum" or "top".

\settexttoken{truth}{truth}{truth}

% - `structure`: term for first-order structures, defaults to
% "structure", redefine for "interpretation", "model".

\settexttoken{structure}{structure}{structures}

% - `enumerable`: term for finite or countably infinite; defaults to
% "enumerable", redefine for "countable".

\settexttoken{enumerable}{enumerable}{enumerable}

% - `denumerable`: term for countably infinite; defaults to "denumerable". 

\settexttoken{denumerable}{denumerable}{denumerable}

% Tags
% ====

% Tags are used to guide selective compilation, using
% `sty/open-logic-selective.sty`.  Tags are initialized using
% `\tagtrue` and `\tagfalse`, which also initialize, for each `tag`
% given as argument, a corresponding tag `nottag` with opposite truth
% value is automatically provided. 

% - Primitives: tags for (sets of) operators which are treated as
%   primitives. Default: all as primitives. 

\tagtrue{prvNot,prvOr,prvAnd,prvIf,prvIff,prvTrue,prvFalse,prvEx,prvAll}

% - Defined operators: tags for operators which are defined, not
%  primitive. Default: none.  Note: Not all combinations of
%  primitive/defined operators will result in complete definitions!

\tagfalse{defNot,defOr,defAnd,defIf,defIff,defTrue,defFalse,defEx,defAll}

% - Cases in proofs: tags for (sets of) operators for which cases are
%   proved; if the corresponding tag is off then the case is added as
%   a problem. Default: prove all cases. Note: propositional constants
%   are part of induction base case and are always treated, if
%   included.

\tagfalse{probNot,probOr,probAnd,probIf,probIff,probEx,probAll}

% - Limit clause in inductive definitions: do you want inductive
% definitions to have a "Nothing else is a ..." clause?

\tagtrue{limitClause}

% tagTrue - a true tag respectively.

\tagtrue{tagTrue}
