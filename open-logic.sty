% OpenLogic Project
% Master Style Package

\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{open-logic}

\RequirePackage{open-logic-referencing}

\RequirePackage{xparse}

\RequirePackage{amsmath}

\RequirePackage{amsfonts}
\RequirePackage{amssymb}
\RequirePackage[OMLmathsfit]{isomath}
\RequirePackage{proof}
\RequirePackage{hyperref}
\RequirePackage{amsthm}
\RequirePackage[nameinlink]{cleveref}
\RequirePackage{bussproofs}

% make ! active in math mode for formula meta variables

{\catcode`!=\active
\gdef!{\formula}
\let\formula\relax % default: do nothing
}
\mathcode`\!="8000 % set ! active in math mode


% greekformulas -- formula metavariables are phi, psi, etc.
% Provides !A, !B etc in math mode to produce \phi, \psi etc.
\DeclareOption{greekformulas}
{\gdef\formula{%
  \@ifnextchar A{\varphi\@gobble}{
  \@ifnextchar B{\psi\@gobble}{
  \@ifnextchar C{\chi\@gobble}{
  \@ifnextchar D{\theta\@gobble}{
  \@ifnextchar E{\alpha\@gobble}{
  \@ifnextchar F{\beta\@gobble}{
  \@ifnextchar G{\gamma\@gobble}{
  \@ifnextchar H{\delta\@gobble}{
  \@ifnextchar K{\xi\@gobble}{
  \@ifnextchar L{\zeta\@gobble}\relax
}}}}}}}}}}}

\ProcessOptions\relax

% Symbols
% =======

% Logical symbols

% truth values
\DeclareDocumentCommand \True {} {1}
\DeclareDocumentCommand \False {} {0}

% falsity is \lfalse
\let\lfalse\bot

% truth is \ltrue
\let\ltrue\top

% negation is \lnot
% for tilde replace with
% \renewcommand*{\lnot}{\mathord{\sim}}

% conjunction is \land
% for ampersand replace with
% \renewcommand*{\land}{\mathbin{\&}}

% disjunction is \lor

% conditional is \lif
% for horseshoe replace with
% \let\lif\supset
\let\lif\to

% biconditional is \liff
% for triple bar replace with
% \let\liff\equiv
\let\liff\leftrightarrow

% existential quantifier is \lexists
% optional argument takes bound variable as argument
% redefine if you want parentheses around quantifiers
\DeclareDocumentCommand \lexists { o o } {
    \IfNoValueTF {#1} 
        { \exists }
        { \exists #1 }
    \IfNoValueTF {#2} 
        \relax
        { \, #2 }
}

% universal quantifier is \lforall
% optional argument takes bound variable as argument
% redefine if you want parentheses around quantifiers
\DeclareDocumentCommand \lforall { o o } {
    \IfNoValueTF {#1} 
        { \forall }
        { \forall #1 }
    \IfNoValueTF {#2} 
        \relax
        { \, #2 }
}

% identity relation
% \eq by itself produces identit predicate symbol
% \eq[#1][#2] produces atomic formula
% \eq/ produces negated symbol/formula.
\DeclareDocumentCommand \eq { t{/} o o } {
  \IfNoValueTF {#3}{
    \IfBooleanTF{#1}{ \neq }{ = }}{
    \IfBooleanTF{#1}{ #2 \neq #3}{#2 = #3}}
}


% sequent symbol is a double arrow
\let\Sequent\Rightarrow

% sequent symbol in proofs displays as the above sequent symbol
\let\fCenter\Sequent

% satisfaction/truth relation
\DeclareDocumentCommand \Sat { t{/} m m o } {
  \IfBooleanTF{#1}{
    \IfNoValueTF {#4} 
        { \Struct #2 \not\models #3 }
        { \Struct #2 \not\models #3 \, [#4]}}{
    \IfNoValueTF {#4} 
        { \Struct #2 \models #3 }
        { \Struct #2 \models #3 \, [#4]}}
}


% derivability relation
\DeclareDocumentCommand \Proves { t{/} o } {
  \IfBooleanTF {#1}{
    \IfNoValueTF {#2} 
        { \not\vdash }
        { \not\vdash_{#2} }}{
    \IfNoValueTF {#2} 
        { \vdash }
        { \vdash_{#2} }}
}

% semantic consequence relation relation
\DeclareDocumentCommand \Entails { o } {
    \IfNoValueTF {#1} 
        { \models }
        { \models_{#1} }
}

% substructure
\let\substruct\subseteq

%Sets

\DeclareDocumentCommand \Setabs { m m } {
\{ #1 : #2 \}}

\DeclareDocumentCommand \Pow { m } {\wp(#1)}

% special sets

\def\Nat{\mathbb{N}}
\def\Int{\mathbb{Z}}
\def\Real{\mathbb{R}}
\def\Rat{\mathbb{Q}}
\def\BinStr{\mathbb{B}}


% typesetting commands for logical concepts
% =========================================

% modal models set in Fraktur by default
\let\Mod\mathfrak

% structures set in Fraktur by default
\let\Struct\mathfrak

% languages set in Script font by default
\let\Lang\mathcal

% logics set boldface Roman by default
\let\Log\mathbf

% object-language symbols set in sans-serif italics
\let\Obj\mathsfit

% atomic formula
% TO DO: provide xparse document processor to remove commas from #2
\DeclareDocumentCommand \Atom { m m } {
        { #1(#2) }
}

% domain of a structure
\def\Domain#1{\left| \Struct #1 \right|}

% assignment of a constant/predicate symbol in a structure
\def\Assign#1#2{#1^{\Struct #2}}


% value of a term symbol in a structure
\DeclareDocumentCommand \Value { m m o} {
    \IfNoValueTF {#3}
        { \mathrm{Val}^{\Struct #2}(#1) }
        { \mathrm{Val}^{\Struct #2}_{#3}(#1) }
}





% commands for various special sets
% =================================

% propositional variables
\def\Var{\mathrm{Var}}

% Terms (optional argument: language
\DeclareDocumentCommand \Trm { o } {
    \IfNoValueTF {#1} 
        { \mathrm{Trm} }
        { \mathrm{Trm}({\Lang #1}) }
}

% Formulas
\DeclareDocumentCommand \Frm { o } {
    \IfNoValueTF {#1} 
        { \mathrm{Frm} }
        { \mathrm{Frm}({\Lang #1}) }
}

% Sub Formulas
\DeclareDocumentCommand \SubFrm { m } {
        \mathrm{SFrm}({#1})
}

% Sentences
\DeclareDocumentCommand \Sent { o } {
    \IfNoValueTF {#1} 
        { \mathrm{Sent} }
        { \mathrm{Sent}({\Lang #1}) }
}


% syntactic identity
\let\ident\equiv
% domain
\def\dom#1{\mathrm{dom}(#1)}
% range
\def\ran#1{\mathrm{ran}(#1)}
% length
\def\len#1{\mathrm{len}(#1)}
% restrict
\let\restrict\upharpoonright

\theoremstyle{plain}
\newtheorem{thm}{Theorem}[chapter]
\crefname{thm}{theorem}{theorems}
\newtheorem{lem}[thm]{Lemma}
\crefname{lem}{lemma}{lemmata}
\newtheorem{prop}[thm]{Proposition}
\crefname{prop}{proposition}{propositions}
\newtheorem{cor}[thm]{Corollary}
\crefname{cor}{corollary}{corollaries}

\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\crefname{defn}{definition}{definitions}
\newtheorem{ex}[thm]{Example}
\crefname{ex}{example}{examples}
\newtheorem{prob}{Problem}[chapter]
\crefname{prob}{problem}{problems}

\theoremstyle{remark}
\newtheorem*{rem}{Remark}
\newtheorem*{note}{Note}
\newtheorem{case}{Case}
\newtheorem{conv}{Convention}

% Other Enviroments
% =================

% wordy -- for wordy informal explanations
\newenvironment{wordy}{\marginpar{\color{blue}\textsc{wordy\quad}}}{}

% intro -- for comments and comparisions to intro texts
\newenvironment{intro}{\marginpar{\color{blue}\textsc{intro\quad}}}{}

% pedantic -- for pedantic comments
\newenvironment{pedantic}{\marginpar{\color{blue}\textsc{padantic\quad}}}{}


% Tokens 
% ====== 

% Text that should be uniform, and changeable Has four forms: in-text
% singular, in-text plural, initial singular, initial plural. Initial
% forms are usually capitalized. They are optional, if left out, we'll
% take the in-text version and make the first letter uppercase.

\usepackage{mfirstuc}

\DeclareDocumentCommand \settexttoken { m m m o o } {
    \expandafter\def\csname TEXTTOK@s@#1\endcsname{#2}
    \expandafter\def\csname TEXTTOK@p@#1\endcsname{#3}
    \IfNoValueTF {#4} 
        { \expandafter\def\csname TEXTTOK@S@#1\endcsname{\makefirstuc{#2}} }
        { \expandafter\def\csname TEXTTOK@S@#1\endcsname{#4} }
    \IfNoValueTF {#5} 
        { \expandafter\def\csname TEXTTOK@P@#1\endcsname{\makefirstuc{#3}} }
        { \expandafter\def\csname TEXTTOK@P@#1\endcsname{#5} }
}

\def\@printtexttokens#1{\csname TEXTTOK@s@#1\endcsname}
\def\@printtexttokenp p#1{\csname TEXTTOK@p@#1\endcsname}
\def\@printtexttokenS S#1{\csname TEXTTOK@S@#1\endcsname}
\def\@printtexttokenP P#1{\csname TEXTTOK@P@#1\endcsname}



%\DeclareDocumentCommand \printtexttoken { m ts}{
%\IfBooleanTF{#2}{
%    \IfBooleanTF{#3}{\printtexttokenP{#1}}
%    {\printtexttokens{#1}}
%}
%{
%    \IfBooleanTF{#3}{\printtexttokenS{#1}}{
%      \printtexttokens{#1}}}}
%}

\def\printtexttoken{\@ifnextchar P{\@printtexttokenP}{%
    \@ifnextchar S{\@printtexttokenS}{%
      \@ifnextchar p{\@printtexttokenp}{\@printtexttokens}}}}

\catcode`\"=\active
\def"{\printtexttoken}


\settexttoken{formula}{formula}{formulae}
\settexttoken{constant}{constant symbol}{constant symbols}
\settexttoken{function}{function symbol}{function symbols}
\settexttoken{predicate}{predicate symbol}{predicate symbols}
\settexttoken{identity}{identity}{identities}

% If compiled standalone as a subfile, execute \OLSubfileHook at beginning
\ifx\document\comment
\AtBeginDocument{\OLSubfileHook}
\fi
\let\OLSubfileHook\relax
